// -*- C++ -*-
#ifndef _LIBCPP_ANY
#define _LIBCPP_ANY

/**
    any synopsis
    

// C++1y
namespace std { namespace experimental { inline namespace any_v1 {
  class bad_any_cast : public bad_cast
  {
  public:
    virtual const char* what() const noexcept;
  };

  class any
  {
  public:
    // construct/destruct
    any() noexcept;

    any(const any& other);
    any(any&& x) noexcept;

    template <typename ValueType>
      any(ValueType&& value);

    template <class Allocator>
      any(allocator_arg_t, const Allocator& a) noexcept;
    template <class Allocator, typename ValueType>
      any(allocator_arg_t, const Allocator& a, ValueType&& value);
    template <class Allocator>
      any(allocator_arg_t, const Allocator& a, const any& other);
    template <class Allocator>
      any(allocator_arg_t, const Allocator& a, any&& other) noexcept;

   ~any();
  
    // assignments
    any& operator=(const any& rhs);
    any& operator=(any&& rhs) noexcept;

    template <typename ValueType>
      any& operator=(ValueType&& rhs);

    // modifiers
    void clear() noexcept;
    void swap(any& rhs) noexcept;

    // observers
    bool empty() const noexcept;
    const type_info& type() const noexcept;
  };

  void swap(any& x, any& y) noexcept;

  template<typename ValueType>
    ValueType any_cast(const any& operand);
  template<typename ValueType>
    ValueType any_cast(any& operand);
  template<typename ValueType>
    ValueType any_cast(any&& operand);

  template<typename ValueType>
    const ValueType* any_cast(const any* operand) noexcept;
  template<typename ValueType>
    ValueType* any_cast(any* operand) noexcept;
}}} // std::experimental::any_v1
    
*/

# include <__config>
# include <typeinfo>

namespace std { namespace experimental {

// Get bad_any_cast into the dylib even if not compiling for C++1y
class _LIBCPP_EXCEPTION_ABI bad_any_cast
  : public bad_cast
{
public:
    virtual const char* what() const _NOEXCEPT;

    // TODO Destructor not specified
    virtual ~bad_any_cast() _NOEXCEPT;
};

}} // std::experimental

#if _LIBCPP_STD_VER > 11

#include <memory>
#include <tuple>
#include <type_traits>
#include <new> /* placement new */
#include <__functional_base> /* allocator_arg_t */


#ifdef _LIBCPP_DEBUG
#   include <__debug>
#else
#   define _LIBCPP_ASSERT(x, m) ((void)0)
#endif

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

// 
namespace std { namespace experimental { inline namespace any_v1 {
    
    namespace __any
    {
        
        /** The buffer type used for the small object optimization. */
        typedef typename _VSTD::aligned_storage<3*sizeof(void*)>::type __buffer;
        
        /** The predicate to check if an object can be stored locally.
         * 1. sizeof(T) <= sizeof(Buffer)
         * 2. Alignment
         * 3. It must be nothrow move constructible.
         */
        template <class _Storage>
        struct __is_small_object
          : public integral_constant<bool
              , sizeof(_Storage) <= sizeof(__buffer)
                && alignment_of<__buffer>::value 
                    % alignment_of<_Storage>::value == 0
                    /* TODO: Check the standard. Is it guarenteed that allocators
                    * aro noexcept move constructible?
                    */
                && is_nothrow_move_constructible<
                      typename _Storage::__value_type
                    >::value
              >
       {};
        
        
        class __storage_base
        {
            __storage_base(__storage_base const &);
            __storage_base & operator=(__storage_base const &);
            
        public:
            _LIBCPP_INLINE_VISIBILITY __storage_base() {}
            _LIBCPP_INLINE_VISIBILITY virtual ~__storage_base() {}
            virtual __storage_base* __copy() const = 0;
            virtual __storage_base* __copy(void*) const = 0;
            virtual __storage_base* __move(void*) = 0;
            
            /** __destroy() handles both deallocation and destruction, since 
             * it knows if an object is stored on the stack or the heap
             * Thats one less virtual overload needed vs the extra
             * __destroy_deallocate() that std::function has.
             * TODO: is that worth it?
             */
            virtual void __destroy() _NOEXCEPT = 0;
            
            virtual void const* __target(type_info const &) const _NOEXCEPT = 0;
            virtual type_info const & __target_type() const _NOEXCEPT = 0;
        };
        
        template <class _Tp, class _Alloc>
        class __storage : public __storage_base
        {
            __compressed_pair<_Tp, _Alloc> __store_;

        public:
            
            typedef _Tp __value_type;
            typedef _Alloc __alloc_type;
            
            _LIBCPP_INLINE_VISIBILITY
            explicit __storage(_Tp && __v)
                : __store_(piecewise_construct
                    , _VSTD::forward_as_tuple(_VSTD::move(__v))
                    , _VSTD::forward_as_tuple()) 
            {}
            
            _LIBCPP_INLINE_VISIBILITY
            explicit __storage(_Tp const & __v, _Alloc const & __a)
              : __store_(piecewise_construct
                  , _VSTD::forward_as_tuple(__v)
                  , _VSTD::forward_as_tuple(__a))
            {}
            
            _LIBCPP_INLINE_VISIBILITY
            explicit __storage(_Tp const & __v, _Alloc && __a)
              : __store_(piecewise_construct
                  , _VSTD::forward_as_tuple(__v)
                  , _VSTD::forward_as_tuple(_VSTD::move(__a)))
            {}
            
            _LIBCPP_INLINE_VISIBILITY
            explicit __storage(_Tp && __v, _Alloc && __a)
              : __store_(piecewise_construct
                  , _VSTD::forward_as_tuple(_VSTD::move(__v))
                  , _VSTD::forward_as_tuple(_VSTD::move(__a)))
            {}
            
            virtual __storage_base* __copy() const;
            virtual __storage_base* __copy(void*) const;
            virtual __storage_base* __move(void*);
            
            virtual void __destroy() _NOEXCEPT;
            
            virtual void const *__target(type_info const &) const _NOEXCEPT;
            virtual type_info const & __target_type() const _NOEXCEPT;
        };
        
        template <class _Tp, class _Alloc>
        __storage_base* 
        __storage<_Tp, _Alloc>::__copy() const
        {
            typedef allocator_traits<_Alloc> __alloc_traits;
            typedef typename __alloc_traits::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
                rebind_traits<__storage>
#else
                rebind_traits<__storage>::other
#endif
                                            _BaseTraits;
            typedef typename _BaseTraits::allocator_type _Ap;
            
            _Ap __a(__store_.second());
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__storage, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            
            _BaseTraits::construct(
                __a, __hold.get()
              , __store_.first(), _VSTD::move(__a)
              );
            
            return __hold.release();
        }
        
        template <class _Tp, class _Alloc>
        __storage_base*
        __storage<_Tp, _Alloc>::__copy(void *__dest) const
        {
            return ::new (__dest) __storage(__store_.first(), __store_.second());
        }
        
        template <class _Tp, class _Alloc>
        __storage_base*
        __storage<_Tp, _Alloc>::__move(void *__dest)
        {
            return ::new(__dest) __storage(
                _VSTD::move(__store_.first())
              , _VSTD::move(__store_.second())
              );
        }
        
        template <class _Tp, class _Alloc>
        void 
        __storage<_Tp, _Alloc>::__destroy() _NOEXCEPT
        {
            typedef allocator_traits<_Alloc> __alloc_traits;
            typedef typename __alloc_traits::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
                rebind_alloc<__storage>
#else
                rebind_alloc<__storage>::other
#endif
                                            _Ap;
            
            if (!__is_small_object<__storage>::value) {
                _Ap __a(__store_.second());
                __store_.~__compressed_pair<_Tp, _Alloc>();
                __a.deallocate(this, 1);
            } else {
                __store_.~__compressed_pair<_Tp, _Alloc>();
            }
            
        }
        
        
        template <class _Tp, class _Alloc>
        void const *
        __storage<_Tp, _Alloc>::__target(type_info const & __info) const _NOEXCEPT
        {
            if (__info == typeid(_Tp)) {
                return _VSTD::addressof(__store_.first());
            } else {
                return static_cast<void const *>(nullptr);
            }
        }

        template <class _Tp, class _Alloc>
        type_info const & 
        __storage<_Tp, _Alloc>::__target_type() const _NOEXCEPT
        {
            return typeid(_Tp);
        }
    }                                                       // namespace __any
    
    class _LIBCPP_TYPE_VIS_ONLY any
    {
        typedef __any::__buffer __buffer;
        typedef __any::__storage_base __base;
        __buffer __buf_;
        __base* __base_;
    public:
        
    // constructors
        _LIBCPP_INLINE_VISIBILITY
        any() _NOEXCEPT : __base_(nullptr) {}
        
        any(any const &);
        
        any(any &&) _NOEXCEPT;
        
        /** Remarks: This constructor shall not participate in overload resolution
         *          if decay<ValueType>::type is the same type as std::any. */
        // TODO: I really wish this constructor was explicit. File a defect report?
        template <
            class _Tp
          , class = typename enable_if<!is_same<
                typename decay<_Tp>::type
              , any
            >::value>::type
          >
        any(_Tp && __v);

        // TODO Can delegating constructors be used?
        template <class _Alloc>
        _LIBCPP_INLINE_VISIBILITY
        any(allocator_arg_t, _Alloc const &) _NOEXCEPT
          : __base_(nullptr) 
        {}
          
        // TODO Can this be supported? I don't think so.
        // TODO Can delegating constructors be used?
        template <class _Alloc>
        _LIBCPP_INLINE_VISIBILITY
        any(allocator_arg_t, _Alloc const &, any const & __other)
          : any(__other)
        {}
        // TODO Can delegating constructors be used?
        template <class _Alloc>
        _LIBCPP_INLINE_VISIBILITY
        any(allocator_arg_t, _Alloc const &, any && __other) _NOEXCEPT
          : any(static_cast<any &&>(__other))
        {}
          
        /** Remarks: This constructor shall not participate in overload resolution
         *          if decay<ValueType>::type is the same type as std::any. */
        template <
            class _Alloc, class _Tp
          , class = typename enable_if<!is_same<
                typename decay<_Tp>::type
              , any
              >::value>::type
          >
        any(allocator_arg_t, _Alloc const & __a0, _Tp && __v);
        
    // destructor
        _LIBCPP_INLINE_VISIBILITY
        ~any() { clear(); }
        
    // assignments
         
         // Effects: any(rhs).swap(*this), however, no effects if an exception 
         // is thrown.
        _LIBCPP_INLINE_VISIBILITY
        any & operator=(any const & __other)
        {
            any(__other).swap(*this);
            return *this;
        }
        
        _LIBCPP_INLINE_VISIBILITY
        any & operator=(any && __other) _NOEXCEPT
        {
            any(_VSTD::move(__other)).swap(*this);
            return *this;
        }
        
        /** Remarks: This operator shall not participate in overload resolution
         *          if decay<ValueType>::type is the same type as std::any. */
        template <
            class _Tp
          , class = typename enable_if<
              !is_same<typename decay<_Tp>::type, any>::value
            >::type
          >
        _LIBCPP_INLINE_VISIBILITY
        any & operator=(_Tp && __v)
        {
            typedef typename decay<_Tp>::type _ValueType;
            static_assert(
                is_copy_constructible<_ValueType>::value
              , "ValueType must be copy constructible"
            );
            any(_VSTD::forward<_Tp>(__v)).swap(*this);
            return *this;
        }
            
    // modifiers
        void clear() _NOEXCEPT;
        void swap(any &) _NOEXCEPT;
        
    // observers
        _LIBCPP_INLINE_VISIBILITY
        bool empty() const _NOEXCEPT
        { return __base_ == nullptr; }
        
        _LIBCPP_INLINE_VISIBILITY
        type_info const & type() const _NOEXCEPT
        { return __base_ ? __base_->__target_type() : typeid(void) ; }
        
    private:
        template <class _Tp> friend typename add_pointer<typename add_const<_Tp>::type>::type any_cast(any const *) _NOEXCEPT;
        template <class _Tp> friend typename add_pointer<_Tp>::type any_cast(any *) _NOEXCEPT;
    };                                                      // class any
    
    inline _LIBCPP_INLINE_VISIBILITY
    any::any(any const & __other)
    {
        if (__other.__base_ == nullptr) {
            __base_ = nullptr;
        }
        else if (__other.__base_ == (__base const*) &__other.__buf_) {
            __base_ = (__base*) &__buf_;
            __other.__base_->__copy(__base_);
        } else {
            __base_ = __other.__base_->__copy();
        }
    }
    
    inline _LIBCPP_INLINE_VISIBILITY
    any::any(any && __other) _NOEXCEPT
    {
        if (__other.__base_ == (__base*) &__other.__buf_) {
            __base_ = (__base*) &__buf_;
            __other.__base_->__move(__base_);
        } else {
            __base_ = __other.__base_;
            __other.__base_ = nullptr;
        }
    }
    
    template <class _Tp, class>
    any::any(_Tp && __v)
    {
        typedef typename decay<_Tp>::type _Value;
        static_assert(
            is_copy_constructible<_Value>::value
          , "Construction of any with a non-copyable type is ill-formed."
          );
    
        typedef allocator<_Value> _Ap;
        typedef __any::__storage<_Value, _Ap> _Store;
            
        if (__any::__is_small_object<_Store>::value) {
            __base_ = ::new ((void*)&__buf_) _Store(
                    _VSTD::forward<_Tp>(__v), _Ap()
                );
        } else {
            typedef allocator<_Store> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<_Store, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new ((void*)__hold.get()) _Store(
                _VSTD::forward<_Tp>(__v)
              , allocator<_Value>(__a)
              );
            __base_ = __hold.release();
        }
    }
    
    template <class _Alloc, class _Tp, class>
    any::any(allocator_arg_t, _Alloc const & __a0, _Tp && __v)
    {
        typedef typename decay<_Tp>::type _Value;
        typedef allocator_traits<_Alloc> __alloc_traits;
        typedef __any::__storage<_Value, _Alloc> _Store;
            
        if (__any::__is_small_object<_Store>::value) {
            __base_ = ::new ((void*) &__buf_) _Store(
                  _VSTD::forward<_Tp>(__v),  _Alloc(__a0)
                );
        } else {
            typedef typename __alloc_traits::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
                rebind_traits<_Store>
#else
                rebind_traits<_Store>::other
#endif
                                            _BaseAlloc;
            typedef typename _BaseAlloc::allocator_type _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<_Store, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            _BaseAlloc::construct(
                __a, __hold.get()
              , _VSTD::forward<_Tp>(__v), _Alloc(__a)
              );
            __base_ = __hold.release();
        }
    }
    
    inline _LIBCPP_INLINE_VISIBILITY
    void any::clear() _NOEXCEPT
    {
        if (__base_) {
            __base_->__destroy();
        }
        __base_ = nullptr;
    }
    
    inline void any::swap(any & __other) _NOEXCEPT
    {
        // Both objects stored locally
        if (__base_ ==  (__base*) &__buf_ 
            && __other.__base_ == (__base*) &__other.__buf_)
        {
            __buffer __tmp;
            __base* __tmp_base = __base_->__move(&__tmp);
            __base_->__destroy();
            
            __base_ = __other.__base_->__move(&__buf_);
            __other.__base_->__destroy();
            
            __other.__base_ = __tmp_base->__move(&__other.__buf_);
            __tmp_base->__destroy();
        }
        // Other's object is remote or null
        else if (__base_ ==  (__base*) &__buf_) 
        {
            __base* __tmp_base = __other.__base_;
            __other.__base_ = __base_->__move(&__other.__buf_);
            __base_->__destroy();
            __base_ = __tmp_base;
        }
        // Our object is remote or null
        else if (__other.__base_ == (__base*) &__other.__buf_) {
            __base* __tmp_base = __base_;
            __base_ = __other.__base_->__move(&__buf_);
            __other.__base_->__destroy();
            __other.__base_ = __tmp_base;
        }
        // Both objects are remote
        else { 
            _VSTD::swap(__base_, __other.__base_);
        }        
    }
    
    
    inline _LIBCPP_INLINE_VISIBILITY
    void swap(any & __lhs, any & __rhs) _NOEXCEPT
    {
        __lhs.swap(__rhs);
    }
    
    // TODO: The return type has to be deduced using traits.
    // If it is specified as: "_Tp const *" then substitution failure will
    // occur when _Tp = T &. The add_pointer trait seems to handle this case
    // by removing the reference and applying the pointer.
    // The nasty thing about that bug is that it would cause the pointer overloads
    // to drop out of the candidates set. Then the compiler will apply any's
    // coverting constructor "template <class T> any(T &&)". The end result was
    // essentially "any_cast<T>((any(__any_ptr))"
    template <class _Tp>
    _LIBCPP_INLINE_VISIBILITY
    typename add_pointer<typename add_const<_Tp>::type>::type 
    any_cast(any const* __a) _NOEXCEPT
    {
        typedef typename add_pointer<typename add_const<_Tp>::type>::type _RetType;
        return __a && __a->__base_ 
            ? static_cast<_RetType>(__a->__base_->__target(typeid(_Tp)))
            : nullptr;
    }
    
    template <class _Tp>
    _LIBCPP_INLINE_VISIBILITY
    typename add_pointer<_Tp>::type 
    any_cast(any * __a) _NOEXCEPT
    {
        typedef typename add_pointer<_Tp>::type _RetType;
        return __a && __a->__base_
            ? static_cast<_RetType>(const_cast<void*>(
                __a->__base_->__target(typeid(_Tp))
              ))
            : nullptr;
    }
    
    template <class _Tp>
    _LIBCPP_INLINE_VISIBILITY
    _Tp any_cast(any const & __a)
    {
        static_assert(
            is_reference<_Tp>::value || is_copy_constructible<_Tp>::value
          , "ValueType must be a reference or copy constructible"
        );
        static_assert(
            !is_reference<_Tp>::value 
            || is_const<typename remove_reference<_Tp>::type>::value
          , "Returning a reference to non-const violates const correctness"
          );
        typedef typename add_const<typename remove_reference<_Tp>::type>::type
            _CastType;
        _CastType * __ret = any_cast<_CastType>(&__a);
        if (__ret == nullptr) {
            throw bad_any_cast();
        }
        return *__ret;
    }
    
    template <class _Tp>
    _LIBCPP_INLINE_VISIBILITY
    _Tp any_cast(any & __a)
    {
        static_assert(
            is_reference<_Tp>::value || is_copy_constructible<_Tp>::value
          , "ValueType must be a reference or copy constructible"
        );
        
        typedef typename remove_reference<_Tp>::type _CastType;
        _CastType * __ret = any_cast<_CastType>(&__a);
        if (__ret == nullptr) {
            throw bad_any_cast();
        }
        return *__ret;
    }
    
    template <class _Tp>
    _LIBCPP_INLINE_VISIBILITY
    _Tp any_cast(any && __a)
    {
        return any_cast<_Tp>(static_cast<any &>(__a));
    }
    
}}}  // namespace std::experimental::any_v1
#endif  // _LIBCPP_STD_VER > 11

#endif  // _LIBCPP_ANY