// -*- C++ -*-
//===------------------------ memory_resource -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE
#define _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE

/**
    experimental/memory_resource synopsis

// C++1y

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
namespace pmr {

  class memory_resource;

  bool operator==(const memory_resource& a,
                  const memory_resource& b) noexcept;
  bool operator!=(const memory_resource& a,
                  const memory_resource& b) noexcept;

  template <class Tp> class polymorphic_allocator;

  template <class T1, class T2>
  bool operator==(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;
  template <class T1, class T2>
  bool operator!=(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;

  // The name resource_adaptor_imp is for exposition only.
  template <class Allocator> class resource_adaptor_imp;

  template <class Allocator>
    using resource_adaptor = resource_adaptor_imp<
      allocator_traits<Allocator>::rebind_alloc<char>>;

  // Global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;

  // The default memory resource
  memory_resource* set_default_resource(memory_resource* r) noexcept;
  memory_resource* get_default_resource() noexcept;

  // Standard memory resources
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;

} // namespace pmr
} // namespace fundamentals_v1
} // namespace experimental
} // namespace std

 */

#include <experimental/__config>
#include <experimental/__memory>
#include <memory>
#include <new>
#include <tuple>
#include <type_traits>
#include <utility>
#include <cstddef>

#   include <__debug>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_LFTS_PMR

// 8.5, memory.resource
class _LIBCPP_TYPE_VIS_ONLY memory_resource
{
    static const  size_t __max_align =
        alignment_of<max_align_t>::value;

// 8.5.2, memory.resource.public
public:
    virtual ~memory_resource();

    _LIBCPP_INLINE_VISIBILITY
    void* allocate(size_t __bytes, size_t __align = __max_align)
    {
        _LIBCPP_ASSERT(__align != 0, "can't be zero");
        _LIBCPP_ASSERT(__is_power2(__align), "alignment must be power of two");
        void * const __ret = do_allocate(__bytes, __align);
        _LIBCPP_ASSERT(
            __alignment_offset(__ret, __max_align < __align ? __max_align : __align) == 0
          , "Incorrect alignment");
        return __ret;
    }

    _LIBCPP_INLINE_VISIBILITY
    void deallocate(void * __p, size_t __bytes, size_t __align = __max_align)
    {
        _LIBCPP_ASSERT(__is_power2(__align), "alignment must be power of two");
        _LIBCPP_ASSERT(
            __alignment_offset(__p, __max_align < __align ? __max_align : __align) == 0
          , "Incorrect alignment");
        do_deallocate(__p, __bytes, __align);
    }

    _LIBCPP_INLINE_VISIBILITY
    bool is_equal(memory_resource const & __other) const _NOEXCEPT
    {
        return do_is_equal(__other);
    }

// 8.5.3, memory.resource.priv
protected:
    virtual void* do_allocate(
        size_t __bytes, size_t __align) = 0;

    virtual void do_deallocate(
        void * __p, size_t __bytes, size_t __align) = 0;

    virtual bool do_is_equal(
        memory_resource const & __other) const _NOEXCEPT = 0;
};

// 8.5.4, memory.resource.eq

inline _LIBCPP_INLINE_VISIBILITY
bool operator==(
    memory_resource const & __lhs
  , memory_resource const & __rhs) _NOEXCEPT
{
    return &__lhs == &__rhs || __lhs.is_equal(__rhs);
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(
    memory_resource const & __lhs
  , memory_resource const & __rhs) _NOEXCEPT
{
    return !(__lhs == __rhs);
}

_LIBCPP_FUNC_VIS
memory_resource * new_delete_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource * null_memory_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource * get_default_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource * set_default_resource(memory_resource * __new_res) _NOEXCEPT;

_LIBCPP_END_NAMESPACE_LFTS_PMR

#endif /* _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE */
