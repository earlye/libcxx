// -*- C++ -*-
//===------------------------ memory_resource -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE
#define _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE

/**
    experimental/memory_resource synopsis

// C++1y

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
namespace pmr {

  class memory_resource;

  bool operator==(const memory_resource& a,
                  const memory_resource& b) noexcept;
  bool operator!=(const memory_resource& a,
                  const memory_resource& b) noexcept;

  template <class Tp> class polymorphic_allocator;

  template <class T1, class T2>
  bool operator==(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;
  template <class T1, class T2>
  bool operator!=(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;

  // The name resource_adaptor_imp is for exposition only.
  template <class Allocator> class resource_adaptor_imp;

  template <class Allocator>
    using resource_adaptor = resource_adaptor_imp<
      allocator_traits<Allocator>::rebind_alloc<char>>;

  // Global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;

  // The default memory resource
  memory_resource* set_default_resource(memory_resource* r) noexcept;
  memory_resource* get_default_resource() noexcept;

  // Standard memory resources
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;

} // namespace pmr
} // namespace fundamentals_v1
} // namespace experimental
} // namespace std


 */

#include <experimental/__config>

#if _LIBCPP_STD_VER > 11

#include <memory>
#include <type_traits>
#include <cstddef>

_LIBCPP_BEGIN_NAMESPACE_LFTS
namespace pmr
{
    class _LIBCPP_TYPE_VIS_ONLY memory_resource
    {
        static constexpr size_t __max_align = std::alignment_of<max_align_t>::value;
    public:
        virtual ~memory_resource() {}

        _LIBCPP_INLINE_VISIBILITY
        void* allocate(size_t __bytes, size_t __align = __max_align)
        {
            return do_allocate(__bytes, __align);
        }

        _LIBCPP_INLINE_VISIBILITY
        void deallocate(void * __p, size_t __bytes, size_t __align = __max_align)
        {
            do_deallocate(__p, __bytes, __max_align);
        }

        _LIBCPP_INLINE_VISIBILITY
        bool is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return do_is_equal(__other);
        }

    protected:
        virtual void* do_allocate(size_t __bytes, size_t __align) = 0;
        virtual void do_deallocate(void * __p, size_t __bytes, size_t __align) = 0;
        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT = 0;
    };

    constexpr size_t memory_resource::__max_align;

    inline _LIBCPP_INLINE_VISIBILITY
    bool operator==(
        memory_resource const & __lhs
      , memory_resource const & __rhs) _NOEXCEPT
    {
        return &__lhs == &__rhs || __lhs.is_equal(__rhs);
    }

    inline _LIBCPP_INLINE_VISIBILITY
    bool operator!=(
        memory_resource const & __lhs
      , memory_resource const & __rhs) _NOEXCEPT
    {
        return !(__lhs == __rhs);
    }

    template <class _Tp> class _LIBCPP_TYPE_VIS_ONLY polymorphic_allocator;

    template <class _Tp, class _Up>
    bool operator==(polymorphic_allocator<_Tp> const &, polymorphic_allocator<_Up> const &) _NOEXCEPT;

    template <class _Tp, class _Up>
    bool operator!=(polymorphic_allocator<_Tp> const &, polymorphic_allocator<_Up> const &) _NOEXCEPT;

    template <class _Alloc> class __resource_adapter_imp;

    template <class _Alloc>
    using resource_adapter
        = __resource_adapter_imp<typename allocator_traits<_Alloc>::template rebind_alloc<char>>;

    memory_resource * new_delete_resource() _NOEXCEPT;
    memory_resource * null_memory_resource() _NOEXCEPT;

    struct _LIBCPP_TYPE_VIS_ONLY pool_options;
    class _LIBCPP_TYPE_VIS_ONLY synchronized_pool_resource;
    class _LIBCPP_TYPE_VIS_ONLY unsynchronized_pool_resource;
    class _LIBCPP_TYPE_VIS_ONLY monotonic_buffer_resource;
}                                                           // namespace pmr
_LIBCPP_END_NAMESPACE_LFTS

#endif /* _LIBCPP_STD_VER > 11 */

#endif /* _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE */
