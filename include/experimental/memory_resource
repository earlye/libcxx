// -*- C++ -*-
//===------------------------ memory_resource -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE
#define _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE

/**
    experimental/memory_resource synopsis

// C++1y

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
namespace pmr {

  class memory_resource;

  bool operator==(const memory_resource& a,
                  const memory_resource& b) noexcept;
  bool operator!=(const memory_resource& a,
                  const memory_resource& b) noexcept;

  template <class Tp> class polymorphic_allocator;

  template <class T1, class T2>
  bool operator==(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;
  template <class T1, class T2>
  bool operator!=(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;

  // The name resource_adaptor_imp is for exposition only.
  template <class Allocator> class resource_adaptor_imp;

  template <class Allocator>
    using resource_adaptor = resource_adaptor_imp<
      allocator_traits<Allocator>::rebind_alloc<char>>;

  // Global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;

  // The default memory resource
  memory_resource* set_default_resource(memory_resource* r) noexcept;
  memory_resource* get_default_resource() noexcept;

  // Standard memory resources
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;

} // namespace pmr
} // namespace fundamentals_v1
} // namespace experimental
} // namespace std

 */

#include <experimental/__config>

#if _LIBCPP_STD_VER > 11

#include <atomic>
#include <experimental/__memory>
#include <memory>
#include <new>
#include <type_traits>
#include <tuple>
#include <utility>
#include <cstddef>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_LFTS_PMR

// 8.5, memory.resource
    class _LIBCPP_TYPE_VIS_ONLY memory_resource
    {
        static constexpr size_t __max_align = alignment_of<max_align_t>::value;

    // 8.5.2, memory.resource.public
    public:
        virtual ~memory_resource() {}

        _LIBCPP_INLINE_VISIBILITY
        void* allocate(size_t __bytes, size_t __align = __max_align)
        {
            return do_allocate(__bytes, __align);
        }

        _LIBCPP_INLINE_VISIBILITY
        void deallocate(void * __p, size_t __bytes, size_t __align = __max_align)
        {
            do_deallocate(__p, __bytes, __align);
        }

        _LIBCPP_INLINE_VISIBILITY
        bool is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return do_is_equal(__other);
        }

    // 8.5.3, memory.resource.priv
    protected:
        virtual void* do_allocate(
            size_t __bytes, size_t __align) = 0;

        virtual void do_deallocate(
            void * __p, size_t __bytes, size_t __align) = 0;

        virtual bool do_is_equal(
            memory_resource const & __other) const _NOEXCEPT = 0;
    };

    // 8.5.4, memory.resource.eq

    inline _LIBCPP_INLINE_VISIBILITY
    bool operator==(
        memory_resource const & __lhs
      , memory_resource const & __rhs) _NOEXCEPT
    {
        return &__lhs == &__rhs || __lhs.is_equal(__rhs);
    }

    inline _LIBCPP_INLINE_VISIBILITY
    bool operator!=(
        memory_resource const & __lhs
      , memory_resource const & __rhs) _NOEXCEPT
    {
        return !(__lhs == __rhs);
    }

// 8.6, memory.polymorphic.allocator.class

    // 8.6.1, memory.polymorphic.allocator.overview
    template <class _ValueType>
    class _LIBCPP_TYPE_VIS_ONLY polymorphic_allocator
    {
        memory_resource * __res_;

        template <class _Tuple>
        _LIBCPP_INLINE_VISIBILITY
        _Tuple && __transform_tuple(integral_constant<int, 0>, _Tuple && __t) const
        {
            return _VSTD::forward<_Tuple>(__t);
        }

        template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        tuple<allocator_arg_t, memory_resource*, _Args...>
        __transform_tuple(integral_constant<int, 1>, tuple<_Args...> && __t) const
        {
            return _VSTD::tuple_cat(
                _VSTD::make_tuple(allocator_arg, resource())
              , _VSTD::move(__t)
              );
        }

        template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        tuple<_Args..., memory_resource*>
        __transform_tuple(integral_constant<int, 2>, tuple<_Args...> && __t) const
        {
            return _VSTD::tuple_cat(
                _VSTD::move(__t), _VSTD::make_tuple(resource())
              );
        }

    public:
        typedef _ValueType value_type;

        // 8.6.2, memory.polymorphic.allocator.ctor
        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator() _NOEXCEPT
          : __res_(_VSTD_LFTS_PMR::get_default_resource())
        {}

        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator(memory_resource * __r) _NOEXCEPT
          : __res_(__r)
        {}

        polymorphic_allocator(polymorphic_allocator const &) = default;

        template <class _Tp>
        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator(
            polymorphic_allocator<_Tp> const & __other) _NOEXCEPT
          : __res_(__other.resource())
        {}

        polymorphic_allocator &
        operator=(polymorphic_allocator const &) = default;

        // 8.6.3, memory.polymorphic.allocator.mem
        _LIBCPP_INLINE_VISIBILITY
        _ValueType* allocate(size_t __n)
        {
            return static_cast<_ValueType*>(
                __res_->allocate(__n * sizeof(_ValueType)
                                , alignment_of<_ValueType>::value)
              );
        }

        _LIBCPP_INLINE_VISIBILITY
        void deallocate(_ValueType * __p, size_t __n) _NOEXCEPT
        {
            __res_->deallocate(
                __p, __n * sizeof(_ValueType)
              , alignment_of<_ValueType>::value
              );
        }

        template <class _Tp, class ..._Ts>
        _LIBCPP_INLINE_VISIBILITY
        void construct(_Tp* __p, _Ts &&... __args)
        {
            _VSTD_LFTS::__lfts_user_alloc_construct(
                __p, resource(), _VSTD::forward<_Ts>(__args)...
              );
        }

        template <class _T1, class _T2, class ..._Args1, class ..._Args2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2>* __p, piecewise_construct_t
            , tuple<_Args1...> __x, tuple<_Args2...> __y)
        {
          ::new ((void*)__p) pair<_T1, _T2>(piecewise_construct
            , __transform_tuple(
                typename __lfts_uses_alloc_ctor<
                    _T1, memory_resource*, _Args1...
                >::type()
              , _VSTD::move(__x)
              )
            , __transform_tuple(
                typename __lfts_uses_alloc_ctor<
                    _T2, memory_resource*, _Args2...
                >::type()
              , _VSTD::move(__y)
              )
            );
        }

        template <class _T1, class _T2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2>* __p)
        {
            construct(__p, piecewise_construct, tuple<>(), tuple<>());
        }

        template <class _T1, class _T2, class _Up, class _Vp>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2> * __p, _Up && __u, _Vp && __v)
        {
            construct(__p, piecewise_construct
              , _VSTD::forward_as_tuple(_VSTD::forward<_Up>(__u))
              , _VSTD::forward_as_tuple(_VSTD::forward<_Vp>(__v)));
        }

        template <class _T1, class _T2, class _U1, class _U2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2> * __p, pair<_U1, _U2> const & __pr)
        {
            construct(__p, piecewise_construct
                , _VSTD::forward_as_tuple(__pr.first)
                , _VSTD::forward_as_tuple(__pr.second));
        }

        template <class _T1, class _T2, class _U1, class _U2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2> * __p, pair<_U1, _U2> && __pr)
        {
            construct(__p, piecewise_construct
                , _VSTD::forward_as_tuple(_VSTD::forward<_U1>(__pr.first))
                , _VSTD::forward_as_tuple(_VSTD::forward<_U2>(__pr.second)));
        }

        template <class _Tp>
        _LIBCPP_INLINE_VISIBILITY
        void destroy(_Tp * __p) _NOEXCEPT
        { __p->~_Tp(); }

        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator
        select_on_container_copy_construction() const _NOEXCEPT
        { return polymorphic_allocator(); }

        _LIBCPP_INLINE_VISIBILITY
        memory_resource * resource() const _NOEXCEPT
        { return __res_; }
    };

    // 8.6.4, memory.polymorphic.allocator.eq

    template <class _Tp, class _Up>
    inline _LIBCPP_INLINE_VISIBILITY
    bool operator==(
        polymorphic_allocator<_Tp> const & __lhs
      , polymorphic_allocator<_Up> const & __rhs) _NOEXCEPT
    {
        return *__lhs.resource() == *__rhs.resource();
    }

    template <class _Tp, class _Up>
    inline _LIBCPP_INLINE_VISIBILITY
    bool operator!=(
        polymorphic_allocator<_Tp> const & __lhs
      , polymorphic_allocator<_Up> const & __rhs) _NOEXCEPT
    {
        return !(__lhs == __rhs);
    }

// 8.7, memory.resource.adaptor

    // 8.7.1, memory.resource.adaptor.overview
    template <class _Alloc> 
    class _LIBCPP_TYPE_VIS_ONLY __resource_adaptor_imp
      : public memory_resource
    {
        _Alloc __alloc_;
        typedef allocator_traits<_Alloc> _Traits;
        typedef typename _Traits::value_type _ValueType;
        typedef typename _Traits::pointer _Pointer;

        static_assert(
            is_same<_ValueType, char>::value
          , "value_type must be char"
          );

    public:
        typedef _Alloc allocator_type;

        __resource_adaptor_imp() = default;
        __resource_adaptor_imp(__resource_adaptor_imp const &) = default;
        __resource_adaptor_imp(__resource_adaptor_imp &&) = default;

        // 8.7.2, memory.resource.adaptor.ctor

        _LIBCPP_INLINE_VISIBILITY
        explicit __resource_adaptor_imp(_Alloc const & __a)
          : __alloc_(__a)
        {}

        _LIBCPP_INLINE_VISIBILITY
        explicit __resource_adaptor_imp(_Alloc && __a)
          : __alloc_(_VSTD::move(__a))
        {}

        __resource_adaptor_imp &
        operator=(__resource_adaptor_imp const &) = default;

        _LIBCPP_INLINE_VISIBILITY
        allocator_type get_allocator() const
        { return __alloc_; }

    // 8.7.3, memory.resource.adaptor.mem
    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align)
        {
            return _Traits::allocate(
                __alloc_, __bytes + (__align - (__bytes % __align))
              );
        }

        virtual void do_deallocate(void * __p, size_t __bytes, size_t __align)
        {
            _Traits::deallocate(
                __alloc_, static_cast<_Pointer>(__p)
              , __bytes + (__align - (__bytes % __align))
              );
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            __resource_adaptor_imp const * __p
              = dynamic_cast<__resource_adaptor_imp const *>(&__other);
            return __p  ? __alloc_ == __p->__alloc_ : false;
        }
    };


    template <class _Alloc>
    using resource_adaptor
        = __resource_adaptor_imp<
            typename allocator_traits<_Alloc>::template rebind_alloc<char>
        >;


    class __new_delete_memory_resource_imp : public memory_resource
    {
    protected:
        virtual void* do_allocate(size_t __size, size_t __align)
        {
            return ::operator new(__size + (__align - (__size % __align)));
        }

        virtual void do_deallocate(void * __p, size_t __size, size_t __align)
        {
            ::operator delete(__p, __size + (__align - (__size % __align)));
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return this ==
                dynamic_cast<__new_delete_memory_resource_imp const *>(&__other);
        }
    };


    class __null_memory_resource_imp : public memory_resource
    {
    protected:
        virtual void* do_allocate(size_t, size_t)
        {
            throw bad_alloc();
        }

        virtual void do_deallocate(void *, size_t, size_t)
        {
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return &__other == static_cast<memory_resource const *>(this);
        }
    };

    inline _LIBCPP_INLINE_VISIBILITY
    memory_resource * new_delete_resource() _NOEXCEPT
    {
        static __new_delete_memory_resource_imp __res;
        return &__res;
    }

    inline _LIBCPP_INLINE_VISIBILITY
    memory_resource * null_memory_resource() _NOEXCEPT
    {
        static __null_memory_resource_imp __res;
        return &__res;
    }

    inline _LIBCPP_INLINE_VISIBILITY
    std::atomic<memory_resource*> * __default_memory_resource() _NOEXCEPT
    {
        static atomic<memory_resource*> __res( new_delete_resource() );
        return &__res;
    }

    inline _LIBCPP_INLINE_VISIBILITY
    memory_resource * set_default_resource(memory_resource * __r) _NOEXCEPT
    {
        memory_resource * __new = __r  ? __r : new_delete_resource();
        return _VSTD::atomic_exchange(__default_memory_resource(), __new);
    }

    inline _LIBCPP_INLINE_VISIBILITY
    memory_resource * get_default_resource() _NOEXCEPT
    {
        return _VSTD::atomic_load(__default_memory_resource());
    }

    struct _LIBCPP_TYPE_VIS_ONLY pool_options
    {
        size_t max_blocks_per_chunk = 0;
        size_t largest_required_pool_block = 0;
    };

	template <size_t _Size>
	struct __memory_resource_chunk
	{
		void *__original_ptr__;
		struct __memory_resource_chunk *__next_free_chunk__;
		struct __memory_resource_chunk *__next_chunk__;
		uint8_t __num_free__;
	}

    template <size_t _Size>
    struct __memory_resource_pool
    {
		size_t blocks_per_chunk() {
			return pool_options.max_blocks_per_chunk < 256 ?
				pool_options.max_blocks_per_chunk : 256;
		}
		void *free_list_head;
		void *chunk_list_head;
		void *get_block(memory_resource *upstream) {
			if (this->free_list_head == NULL) {
				size_t blocks = this->blocks_per_chunk();
				size_t alignment = blocks * _Size;

				void *unaligned = upstream->do_allocate(2 * alignment, 0);
				void *aligned = unaligned / alignment;
				aligned += unaligned % alignment > 0 ? alignment : 0;

				struct __memory_resource_chunk *chunk = aligned;
				chunk->__original_ptr__ = unaligned;
				chunk->__num_free__ = (alignment - sizeof(__memory_resource_chunk)) / _Size;
				// TODO: optimize this by pushing us to the tail
				chunk->__next_free_chunk = this->free_list_head;
				chunk->__next_chunk = this->chunk_list_head;
				this->free_list_head = aligned;
				this->chunk_list_head = aligned;
			}
			struct __memory_resource_chunk *chunk = this->free_list_head;
			size_t chunk_struct_size = sizeof(__memory_resource_chunk);
			size_t chunk_header_size = chunk_struct_size / _Size;
			chunk_header_size += chunk_struct_size % _Size > 0 ? 1 : 0;
			uint8_t *block = (uint8_t *)chunk + _Size * (chunk->__next_free__ + chunk_header_size);
			if (--chunk->__num_free__ == 0) {
				this->free_list_head = chunk->__next_free_chunk__;
			}
			chunk->__next_free__ = *block;
			return block;
		}
		void return_block(void *block_raw) {
			uint8_t *block = (uint8_t *)block_raw;
			size_t blocks = this->blocks_per_chunk();
			size_t alignment = blocks * _Size;
			void *aligned = block / alignment;

			struct __memory_resource_chunk *chunk = aligned;
			if (++chunk->__num_free__ == 1) {
				chunk->__next_free_chunk__ = this->free_list_head;
				this->free_list_head = chunk;
			}

			uint8_t max_free = (alignment - sizeof(__memory_resource_chunk)) / _Size;
			if (++chunk->__num_free__ == max_free) {
				// Dealloc chunk?
			}

			uint8_t block_index = block % alignment;
			*block = chunk->__next_free__;
			chunk->__next_free__ = block_index;
		}
    };

    class _LIBCPP_TYPE_VIS_ONLY synchronized_pool_resource
      : public memory_resource
    {
    public:
        synchronized_pool_resource(
            pool_options const & __opts, memory_resource * __ustream);

        synchronized_pool_resource()
          : synchronized_pool_resource(pool_options(), get_default_resource())
        {}

        explicit synchronized_pool_resource(memory_resource * __ustream)
          : synchronized_pool_resource(pool_options(), __ustream)
        {}

        explicit synchronized_pool_resource(pool_options const & __opts)
          : synchronized_pool_resource(__opts, get_default_resource())
        {}

        synchronized_pool_resource(synchronized_pool_resource const &) = delete;

        virtual ~synchronized_pool_resource() {}

        synchronized_pool_resource & operator=(
            synchronized_pool_resource const &) = delete;

        void release();
        memory_resource * upstream_resource() const;
        pool_options options() const;

    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align);
        virtual void do_deallocate(void * __p, size_t __bytes, size_t __align);
        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT;
    };


    class _LIBCPP_TYPE_VIS_ONLY unsynchronized_pool_resource
      : public memory_resource
    {
    public:
        unsynchronized_pool_resource(
            pool_options const & __opts, memory_resource * __ustream);

        unsynchronized_pool_resource()
          : unsynchronized_pool_resource(pool_options(), get_default_resource())
        {}

        explicit unsynchronized_pool_resource(memory_resource * __ustream)
          : unsynchronized_pool_resource(pool_options(), __ustream)
        {}

        explicit unsynchronized_pool_resource(pool_options const & __opts)
          : unsynchronized_pool_resource(__opts, get_default_resource())
        {}

        unsynchronized_pool_resource(unsynchronized_pool_resource const &) = delete;

        virtual ~unsynchronized_pool_resource() {}

        unsynchronized_pool_resource & operator=(
            unsynchronized_pool_resource const &) = delete;

        void release();
        memory_resource * upstream_resource() const;
        pool_options options() const;

    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align);
        virtual void do_deallocate(void * __p, size_t __bytes, size_t __align);
        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT;
    };


    class _LIBCPP_TYPE_VIS_ONLY monotonic_buffer_resource
      : public memory_resource
    {
    public:
        explicit monotonic_buffer_resource(memory_resource * __ustream);

        monotonic_buffer_resource(
            size_t __init_size, memory_resource * __ustream);

        monotonic_buffer_resource(
            void * __buf, size_t __buf_size, memory_resource * __ustream);

        monotonic_buffer_resource()
          : monotonic_buffer_resource(get_default_resource())
        {}

        explicit monotonic_buffer_resource(size_t __init_size)
          : monotonic_buffer_resource(__init_size, get_default_resource())
        {}

        monotonic_buffer_resource(void * __buf, size_t __buf_size)
          : monotonic_buffer_resource(__buf, __buf_size, get_default_resource())
        {}

        monotonic_buffer_resource(monotonic_buffer_resource const &) = delete;

        virtual ~monotonic_buffer_resource();

        monotonic_buffer_resource & operator=(
            monotonic_buffer_resource const &) = delete;

        void release();
        memory_resource * upstream_resource() const;

    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align);

        virtual void do_deallocate(void *, size_t, size_t)
        {
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return this ==
                dynamic_cast<monotonic_buffer_resource const *>(&__other);
        }
    };

_LIBCPP_END_NAMESPACE_LFTS_PMR

#endif /* _LIBCPP_STD_VER > 11 */

#endif /* _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE */
