// -*- C++ -*-
//===------------------------ memory_resource -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE
#define _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE

/**
    experimental/memory_resource synopsis

// C++1y

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
namespace pmr {

  class memory_resource;

  bool operator==(const memory_resource& a,
                  const memory_resource& b) noexcept;
  bool operator!=(const memory_resource& a,
                  const memory_resource& b) noexcept;

  template <class Tp> class polymorphic_allocator;

  template <class T1, class T2>
  bool operator==(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;
  template <class T1, class T2>
  bool operator!=(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;

  // The name resource_adaptor_imp is for exposition only.
  template <class Allocator> class resource_adaptor_imp;

  template <class Allocator>
    using resource_adaptor = resource_adaptor_imp<
      allocator_traits<Allocator>::rebind_alloc<char>>;

  // Global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;

  // The default memory resource
  memory_resource* set_default_resource(memory_resource* r) noexcept;
  memory_resource* get_default_resource() noexcept;

  // Standard memory resources
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;

} // namespace pmr
} // namespace fundamentals_v1
} // namespace experimental
} // namespace std

 */

#include <experimental/__config>

#if _LIBCPP_STD_VER > 11

#include <atomic>
#include <algorithm>
#include <mutex>
#include <experimental/__memory>
#include <memory>
#include <new>
#include <type_traits>
#include <tuple>
#include <utility>
#include <cstddef>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_LFTS_PMR


    inline _LIBCPP_INLINE_VISIBILITY 
    uint32_t __count_leading_zeros(uint32_t __x) _NOEXCEPT
    {
#if defined(_LIBCPP_GNU_VER)
        return __x ? __builtin_clz(__x) : 32;
#else
        if (__x == 0) return 32;
        uint32_t __n = 0;
        if (__x <= 0x0000FFFF) {__n +=16; __x <<16;}
        if (__x <= 0x00FFFFFF) {__n += 8; __x << 8;}
        if (__x <= 0x0FFFFFFF) {__n += 4; __x << 4;}
        if (__x <= 0x3FFFFFFF) {__n += 2; __x << 2;}
        if (__x <= 0x7FFFFFFF) {__n += 1;}
        return __n;
#endif
    }

    inline _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR
    bool __is_pow_2(size_t __s) _NOEXCEPT
    {
        return __s && !(__s & (__s - 1));
    }

    inline _LIBCPP_INLINE_VISIBILITY
    size_t __next_pow_2(size_t __s) _NOEXCEPT
    {
        const size_t __i = 32 - _VSTD_LFTS_PMR::__count_leading_zeros(__s);
        return __s == 0 || __s == (1U<<__i) ? __s : (1U<<__i+1);
    }
    
    inline _LIBCPP_INLINE_VISIBILITY
    size_t __round_up_pow_2(size_t __s) _NOEXCEPT
    {
        return _VSTD_LFTS_PMR::__is_pow_2(__s) 
            ? __s
            : _VSTD_LFTS_PMR::__next_pow_2(__s);
    }

    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
    size_t __max_alignment() _NOEXCEPT
    {
        return alignment_of<max_align_t>::value;
    }

    // The alignment is 2 ^ (index of lowest set bit)
    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
    size_t __alignment_for(size_t __s) _NOEXCEPT
    {
        return static_cast<int>(__s | __max_alignment())
            & ~(static_cast<int>(__s | __max_alignment()) - 1);
    }

    // Round __s up to next multiple of __a.
    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
    size_t __aligned_allocation_size(size_t __s, size_t __a) _NOEXCEPT
    {
        return (__s + __a - 1) & ~(__a - 1);
    }

    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
    size_t __aligned_block_size(size_t __buf_size, size_t __block_size) _NOEXCEPT
    {
        return _VSTD_LFTS_PMR::__aligned_allocation_size(
                    __buf_size + __block_size, __max_alignment()
                );
    }

// 8.5, memory.resource
    class _LIBCPP_TYPE_VIS_ONLY memory_resource
    {
        static constexpr size_t __max_align = alignment_of<max_align_t>::value;

    // 8.5.2, memory.resource.public
    public:
        virtual ~memory_resource() {}

        _LIBCPP_INLINE_VISIBILITY
        void* allocate(size_t __bytes, size_t __align = __max_align)
        {
            return do_allocate(__bytes, __align);
        }

        _LIBCPP_INLINE_VISIBILITY
        void deallocate(void * __p, size_t __bytes, size_t __align = __max_align)
        {
            do_deallocate(__p, __bytes, __align);
        }

        _LIBCPP_INLINE_VISIBILITY
        bool is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return do_is_equal(__other);
        }

    // 8.5.3, memory.resource.priv
    protected:
        virtual void* do_allocate(
            size_t __bytes, size_t __align) = 0;

        virtual void do_deallocate(
            void * __p, size_t __bytes, size_t __align) = 0;

        virtual bool do_is_equal(
            memory_resource const & __other) const _NOEXCEPT = 0;
    };

    // 8.5.4, memory.resource.eq

    inline _LIBCPP_INLINE_VISIBILITY
    bool operator==(
        memory_resource const & __lhs
      , memory_resource const & __rhs) _NOEXCEPT
    {
        return &__lhs == &__rhs || __lhs.is_equal(__rhs);
    }

    inline _LIBCPP_INLINE_VISIBILITY
    bool operator!=(
        memory_resource const & __lhs
      , memory_resource const & __rhs) _NOEXCEPT
    {
        return !(__lhs == __rhs);
    }

// 8.6, memory.polymorphic.allocator.class

    // 8.6.1, memory.polymorphic.allocator.overview
    template <class _ValueType>
    class _LIBCPP_TYPE_VIS_ONLY polymorphic_allocator
    {
        memory_resource * __res_;

        template <class _Tuple>
        _LIBCPP_INLINE_VISIBILITY
        _Tuple && __transform_tuple(integral_constant<int, 0>, _Tuple && __t) const
        {
            return _VSTD::forward<_Tuple>(__t);
        }

        template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        tuple<allocator_arg_t, memory_resource*, _Args...>
        __transform_tuple(integral_constant<int, 1>, tuple<_Args...> && __t) const
        {
            return _VSTD::tuple_cat(
                _VSTD::make_tuple(allocator_arg, resource())
              , _VSTD::move(__t)
              );
        }

        template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        tuple<_Args..., memory_resource*>
        __transform_tuple(integral_constant<int, 2>, tuple<_Args...> && __t) const
        {
            return _VSTD::tuple_cat(
                _VSTD::move(__t), _VSTD::make_tuple(resource())
              );
        }

    public:
        typedef _ValueType value_type;

        // 8.6.2, memory.polymorphic.allocator.ctor
        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator() _NOEXCEPT
          : __res_(_VSTD_LFTS_PMR::get_default_resource())
        {}

        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator(memory_resource * __r) _NOEXCEPT
          : __res_(__r)
        {}

        polymorphic_allocator(polymorphic_allocator const &) = default;

        template <class _Tp>
        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator(
            polymorphic_allocator<_Tp> const & __other) _NOEXCEPT
          : __res_(__other.resource())
        {}

        polymorphic_allocator &
        operator=(polymorphic_allocator const &) = default;

        // 8.6.3, memory.polymorphic.allocator.mem
        _LIBCPP_INLINE_VISIBILITY
        _ValueType* allocate(size_t __n)
        {
            return static_cast<_ValueType*>(
                __res_->allocate(__n * sizeof(_ValueType)
                                , alignment_of<_ValueType>::value)
              );
        }

        _LIBCPP_INLINE_VISIBILITY
        void deallocate(_ValueType * __p, size_t __n) _NOEXCEPT
        {
            __res_->deallocate(
                __p, __n * sizeof(_ValueType)
              , alignment_of<_ValueType>::value
              );
        }

        template <class _Tp, class ..._Ts>
        _LIBCPP_INLINE_VISIBILITY
        void construct(_Tp* __p, _Ts &&... __args)
        {
            _VSTD_LFTS::__lfts_user_alloc_construct(
                __p, resource(), _VSTD::forward<_Ts>(__args)...
              );
        }

        template <class _T1, class _T2, class ..._Args1, class ..._Args2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2>* __p, piecewise_construct_t
            , tuple<_Args1...> __x, tuple<_Args2...> __y)
        {
          ::new ((void*)__p) pair<_T1, _T2>(piecewise_construct
            , __transform_tuple(
                typename __lfts_uses_alloc_ctor<
                    _T1, memory_resource*, _Args1...
                >::type()
              , _VSTD::move(__x)
              )
            , __transform_tuple(
                typename __lfts_uses_alloc_ctor<
                    _T2, memory_resource*, _Args2...
                >::type()
              , _VSTD::move(__y)
              )
            );
        }

        template <class _T1, class _T2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2>* __p)
        {
            construct(__p, piecewise_construct, tuple<>(), tuple<>());
        }

        template <class _T1, class _T2, class _Up, class _Vp>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2> * __p, _Up && __u, _Vp && __v)
        {
            construct(__p, piecewise_construct
              , _VSTD::forward_as_tuple(_VSTD::forward<_Up>(__u))
              , _VSTD::forward_as_tuple(_VSTD::forward<_Vp>(__v)));
        }

        template <class _T1, class _T2, class _U1, class _U2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2> * __p, pair<_U1, _U2> const & __pr)
        {
            construct(__p, piecewise_construct
                , _VSTD::forward_as_tuple(__pr.first)
                , _VSTD::forward_as_tuple(__pr.second));
        }

        template <class _T1, class _T2, class _U1, class _U2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2> * __p, pair<_U1, _U2> && __pr)
        {
            construct(__p, piecewise_construct
                , _VSTD::forward_as_tuple(_VSTD::forward<_U1>(__pr.first))
                , _VSTD::forward_as_tuple(_VSTD::forward<_U2>(__pr.second)));
        }

        template <class _Tp>
        _LIBCPP_INLINE_VISIBILITY
        void destroy(_Tp * __p) _NOEXCEPT
        { __p->~_Tp(); }

        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator
        select_on_container_copy_construction() const _NOEXCEPT
        { return polymorphic_allocator(); }

        _LIBCPP_INLINE_VISIBILITY
        memory_resource * resource() const _NOEXCEPT
        { return __res_; }
    };

    // 8.6.4, memory.polymorphic.allocator.eq

    template <class _Tp, class _Up>
    inline _LIBCPP_INLINE_VISIBILITY
    bool operator==(
        polymorphic_allocator<_Tp> const & __lhs
      , polymorphic_allocator<_Up> const & __rhs) _NOEXCEPT
    {
        return *__lhs.resource() == *__rhs.resource();
    }

    template <class _Tp, class _Up>
    inline _LIBCPP_INLINE_VISIBILITY
    bool operator!=(
        polymorphic_allocator<_Tp> const & __lhs
      , polymorphic_allocator<_Up> const & __rhs) _NOEXCEPT
    {
        return !(__lhs == __rhs);
    }

// 8.7, memory.resource.adaptor

    // 8.7.1, memory.resource.adaptor.overview
    template <class _Alloc> 
    class _LIBCPP_TYPE_VIS_ONLY __resource_adaptor_imp
      : public memory_resource
    {
        _Alloc __alloc_;
        typedef allocator_traits<_Alloc> _Traits;
        typedef typename _Traits::value_type _ValueType;
        typedef typename _Traits::pointer _Pointer;

        static_assert(
            is_same<_ValueType, char>::value
          , "value_type must be char"
          );

    public:
        typedef _Alloc allocator_type;

        __resource_adaptor_imp() = default;
        __resource_adaptor_imp(__resource_adaptor_imp const &) = default;
        __resource_adaptor_imp(__resource_adaptor_imp &&) = default;

        // 8.7.2, memory.resource.adaptor.ctor

        _LIBCPP_INLINE_VISIBILITY
        explicit __resource_adaptor_imp(_Alloc const & __a)
          : __alloc_(__a)
        {}

        _LIBCPP_INLINE_VISIBILITY
        explicit __resource_adaptor_imp(_Alloc && __a)
          : __alloc_(_VSTD::move(__a))
        {}

        __resource_adaptor_imp &
        operator=(__resource_adaptor_imp const &) = default;

        _LIBCPP_INLINE_VISIBILITY
        allocator_type get_allocator() const
        { return __alloc_; }

    // 8.7.3, memory.resource.adaptor.mem
    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align)
        {
            return _Traits::allocate(
                __alloc_, __bytes + (__align - (__bytes % __align))
              );
        }

        virtual void do_deallocate(void * __p, size_t __bytes, size_t __align)
        {
            _Traits::deallocate(
                __alloc_, static_cast<_Pointer>(__p)
              , __bytes + (__align - (__bytes % __align))
              );
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            __resource_adaptor_imp const * __p
              = dynamic_cast<__resource_adaptor_imp const *>(&__other);
            return __p  ? __alloc_ == __p->__alloc_ : false;
        }
    };


    template <class _Alloc>
    using resource_adaptor
        = __resource_adaptor_imp<
            typename allocator_traits<_Alloc>::template rebind_alloc<char>
        >;


    class __new_delete_memory_resource_imp : public memory_resource
    {
    protected:
        virtual void* do_allocate(size_t __size, size_t __align)
        {
            return ::operator new(__size + (__align - (__size % __align)));
        }

        virtual void do_deallocate(void * __p, size_t __size, size_t __align)
        {
            ::operator delete(__p, __size + (__align - (__size % __align)));
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return this ==
                dynamic_cast<__new_delete_memory_resource_imp const *>(&__other);
        }
    };


    class __null_memory_resource_imp : public memory_resource
    {
    protected:
        virtual void* do_allocate(size_t, size_t)
        {
            throw bad_alloc();
        }

        virtual void do_deallocate(void *, size_t, size_t)
        {
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return &__other == static_cast<memory_resource const *>(this);
        }
    };

    inline _LIBCPP_INLINE_VISIBILITY
    memory_resource * new_delete_resource() _NOEXCEPT
    {
        static __new_delete_memory_resource_imp __res;
        return &__res;
    }

    inline _LIBCPP_INLINE_VISIBILITY
    memory_resource * null_memory_resource() _NOEXCEPT
    {
        static __null_memory_resource_imp __res;
        return &__res;
    }

    inline _LIBCPP_INLINE_VISIBILITY
    std::atomic<memory_resource*> * __default_memory_resource() _NOEXCEPT
    {
        static atomic<memory_resource*> __res( new_delete_resource() );
        return &__res;
    }

    inline _LIBCPP_INLINE_VISIBILITY
    memory_resource * set_default_resource(memory_resource * __r) _NOEXCEPT
    {
        memory_resource * __new = __r  ? __r : new_delete_resource();
        return _VSTD::atomic_exchange(__default_memory_resource(), __new);
    }

    inline _LIBCPP_INLINE_VISIBILITY
    memory_resource * get_default_resource() _NOEXCEPT
    {
        return _VSTD::atomic_load(__default_memory_resource());
    }

    struct _LIBCPP_TYPE_VIS_ONLY pool_options
    {
        size_t max_blocks_per_chunk = 0;
        size_t largest_required_pool_block = 0;

        // Implementation limits
        static const size_t __impl_max_blocks_per_chunk = 32;
        static const size_t __impl_smallest_required_pool_block = 8;
        static const size_t __impl_largest_required_pool_block = 4096;
        static const size_t __impl_max_number_pools =
            (__impl_largest_required_pool_block - __impl_smallest_required_pool_block) / 2;
    };


    inline _LIBCPP_INLINE_VISIBILITY
    pool_options __adjust_pool_options(pool_options __opts) _NOEXCEPT
    {
        return pool_options{
            __opts.max_blocks_per_chunk
                && __opts.max_blocks_per_chunk < pool_options::__impl_max_blocks_per_chunk
                ? __opts.max_blocks_per_chunk : pool_options::__impl_max_blocks_per_chunk
          , __opts.largest_required_pool_block
                && __opts.largest_required_pool_block < pool_options::__impl_largest_required_pool_block
                ? ( __opts.largest_required_pool_block < pool_options::__impl_smallest_required_pool_block
                    ? pool_options::__impl_smallest_required_pool_block
                    : __opts.largest_required_pool_block)
                : pool_options::__impl_largest_required_pool_block
        };
    }

    class __monotonic_chunk_allocator
    {
        struct __chunk_node
        {
            __chunk_node * __next_;
            size_t __size_;
            max_align_t __memory_;
        };

    public:
        static const size_t __chunk_node_size = sizeof(__chunk_node);
        static const size_t __header_size = sizeof(__chunk_node*) + sizeof(size_t);

    public:
        explicit __monotonic_chunk_allocator()
            : __head_(nullptr)
        {}

        __monotonic_chunk_allocator(__monotonic_chunk_allocator const &) = delete;

        __monotonic_chunk_allocator & operator=(__monotonic_chunk_allocator const &) = delete;

        void * __allocate(memory_resource * __res, size_t __s)
        {
            if (! __s) return nullptr;

            const size_t __alloc_size = sizeof(__chunk_node) + __s;
            return __append_chunk(__res->allocate(__alloc_size), __alloc_size);
        }

        void __deallocate(memory_resource * __res, void *) _NOEXCEPT {}

        void __release(memory_resource * __res) _NOEXCEPT
        {
            while (__head_) {
                __chunk_node * __block = __head_;
                __head_ = __block->__next_;
                __res->deallocate(__block, __block->__size_);
            }
        }

        void * __append_chunk(void * __p, size_t __s)
        {
            __chunk_node * __n = static_cast<__chunk_node*>(__p);
            __n->__size_ = __s;
            __n->__next_ = __head_;
            __head_ = __n;
            return static_cast<void*>(&__n->__memory_);
        }

    private:
        __chunk_node * __head_;
        memory_resource * __alloc_; 
    };

#ifdef _LIBCPP_CLEVER_MEMORY_POOL
    template <size_t _Size>
    struct __memory_resource_chunk
    {
        void *__original_ptr_;
        __memory_resource_chunk *__next_free_chunk_;
        __memory_resource_chunk *__next_chunk_;
        uint8_t __num_free_;
        uint8_t __next_free_;
    }

    struct __memory_pool
    {
        size_t blocks_per_chunk() {
            return pool_options.max_blocks_per_chunk < 256 ?
                pool_options.max_blocks_per_chunk : 256;
        }
        void *free_list_head;
        void *chunk_list_head;
        void *get_block(memory_resource *upstream) {
            if (this->free_list_head == NULL) {
                size_t blocks = this->blocks_per_chunk();
                size_t alignment = blocks * _Size;

                void *unaligned = upstream->do_allocate(2 * alignment, 0);
                void *aligned = unaligned / alignment;
                aligned += unaligned % alignment > 0 ? alignment : 0;

                struct __memory_resource_chunk *chunk = aligned;
                chunk->__original_ptr_ = unaligned;
                chunk->__num_free_ = (alignment - sizeof(__memory_resource_chunk)) / _Size;
                // TODO: optimize this by pushing us to the tail
                chunk->__next_free_chunk = this->free_list_head;
                chunk->__next_chunk = this->chunk_list_head;
                this->free_list_head = aligned;
                this->chunk_list_head = aligned;
            }
            struct __memory_resource_chunk *chunk = this->free_list_head;
            size_t chunk_struct_size = sizeof(__memory_resource_chunk);
            size_t chunk_header_size = chunk_struct_size / _Size;
            chunk_header_size += chunk_struct_size % _Size > 0 ? 1 : 0;
            uint8_t *block = (uint8_t *)chunk + _Size * (chunk->__next_free__ + chunk_header_size);
            if (--chunk->__num_free__ == 0) {
                this->free_list_head = chunk->__next_free_chunk__;
            }
            chunk->__next_free__ = *block;
            return block;
        }
        void return_block(void *block_raw) {
            uint8_t *block = (uint8_t *)block_raw;
            size_t blocks = this->blocks_per_chunk();
            size_t alignment = blocks * _Size;
            void *aligned = block / alignment;

            struct __memory_resource_chunk *chunk = aligned;
            if (++chunk->__num_free__ == 1) {
                chunk->__next_free_chunk__ = this->free_list_head;
                this->free_list_head = chunk;
            }

            uint8_t max_free = (alignment - sizeof(__memory_resource_chunk)) / _Size;
            if (++chunk->__num_free__ == max_free) {
                // Dealloc chunk?
            }

            uint8_t block_index = block % alignment;
            *block = chunk->__next_free__;
            chunk->__next_free__ = block_index;
        }
    };
#else /* _LIBCPP_SIMPLE_MEMORY_POOL */

    class _LIBCPP_TYPE_VIS_ONLY __memory_pool
    {
        struct __block_node
        {
            __block_node * __next_;
        };
    public:
        __memory_pool()
            : __block_size_(0)
            , __chunk_size_(1)
            , __max_block_per_chunk_(0)
            , __free_head_(nullptr)
            , __alloc_()
        {}

        __memory_pool(size_t __bsize, size_t __max_cs)
            : __block_size_(__bsize)
            , __chunk_size_(1)
            , __max_block_per_chunk_(__max_cs)
            , __free_head_(nullptr)
            , __alloc_()
        {}

        __memory_pool(__memory_pool const &) = delete;

        ~__memory_pool() { }

        void * __allocate(memory_resource * __res)
        {
            if (!__free_head_) {
                __alloc_new_chunk(__res);
            }
            __block_node * __n = __free_head_;
            __free_head_ = __free_head_->__next_;
            return static_cast<void*>(__n);
        }

        void __deallocate(memory_resource *, void * __p)
        {
            if (! __p) {
                return;
            }
            __block_node * __n = static_cast<__block_node*>(__p);
            __n->__next_ = __free_head_;
            __free_head_ = __n;
        }

        void __release(memory_resource * __res)
        {
            __alloc_.__release(__res);
        }

        void __init_pool_options(size_t __block_size, size_t __max_blocks)
        {
            __block_size_ = __block_size;
            __max_block_per_chunk_ = __max_blocks;
        }

    private:
        void __alloc_new_chunk(memory_resource * __res)
        {
            const size_t __a = __alignment_for(__block_size_);
            const size_t __s = 
                __aligned_allocation_size(__block_size_, __a) * __chunk_size_;
            void * __p = __alloc_.__allocate(__res, __s);
            __add_chunk_to_free_list(__p, __s, __a);
            __increment_max_blocks_per_chunk();
        }

        void __add_chunk_to_free_list(void * __p, size_t __s, size_t __a)
        {
            while (_VSTD::align(__a, __block_size_, __p, __s)) {
                __block_node * __ret = static_cast<__block_node*>(__p);
                __p = static_cast<char*>(__p) + __block_size_;
                __ret->__next_ = __free_head_;
                __free_head_ = __ret;
            }
        }

        void __increment_max_blocks_per_chunk()
        {
            __chunk_size_ = _VSTD::min(__chunk_size_ << 1, __max_block_per_chunk_);
        }

    private:
        size_t __block_size_;
        size_t __chunk_size_;
        size_t __max_block_per_chunk_;
        __block_node * __free_head_;
        __monotonic_chunk_allocator __alloc_;
    };

#endif /* _LIBCPP_CLEVER_MEMORY_POOL */

    class _LIBCPP_TYPE_VIS_ONLY __synchronized_memory_pool
    {
    public:
        __synchronized_memory_pool()
            : __pool_()
        {}

        __synchronized_memory_pool(size_t __bsize, size_t __max_cs)
            : __pool_(__bsize, __max_cs)
        {}

        __synchronized_memory_pool(__synchronized_memory_pool const &) = delete;
        __synchronized_memory_pool & operator=(__synchronized_memory_pool const &) = delete;

        void * __allocate(memory_resource * __res)
        {
            lock_guard<mutex> __guard(__lock_);
            return __pool_.__allocate(__res);
        }

        void __deallocate(memory_resource * __res, void * __p) 
        {
            lock_guard<mutex> __guard(__lock_);
            __pool_.__deallocate(__res, __p);
        }

        void __release(memory_resource * __res)
        {
            lock_guard<mutex> __guard(__lock_);
            __pool_.__release(__res);
        }

        void __init_pool_options(size_t __block_size, size_t __max_block_per_chunk)
        {
            __pool_.__init_pool_options(__block_size, __max_block_per_chunk);
        }

    private:
        mutex __lock_;
        __memory_pool __pool_;
    };


    template <class _PoolType>
    class _LIBCPP_TYPE_VIS_ONLY __pool_resource_base
    {
    public:
        static size_t __index_of(size_t __pow)
        {
            return 36 - _VSTD_LFTS_PMR::__count_leading_zeros(__pow);
        }

        bool __oversized(size_t __s) const 
        {
            return __s > __opts_.largest_required_pool_block;
        }

        size_t __index_for(size_t __s) const
        {
            size_t const __i = _VSTD::max(__round_up_pow_2(__s), pool_options::__impl_smallest_required_pool_block);
            if (__oversized(__i)) {
                return -1;
            }
            return __index_of(__i);
        }

    public:

        __pool_resource_base(pool_options __opts, memory_resource * __res)
            : __opts_(__adjust_pool_options(__opts))
            , __num_pools_(__index_of(__opts_.largest_required_pool_block))
            , __res_(__res)
        {
            __init();
        }

        __pool_resource_base(__pool_resource_base const &) = delete;

        ~__pool_resource_base()
        {
            __release();
        }

        __pool_resource_base & operator=(__pool_resource_base const &) = delete;

        void * __allocate(size_t __s, size_t __a)
        {
            size_t const __alloc_size = __aligned_allocation_size(__s, __a);
            if (__oversized(__alloc_size)) {
                return __oversized_alloc_.__allocate(__res_, __alloc_size);
            } else {
                return __pool_buf_[__index_for(__alloc_size)].__allocate(__res_);
            }
        }

        void __deallocate(void * __p, size_t __s, size_t __a)
        {
            size_t const __alloc_size = __aligned_allocation_size(__s, __a);
            if (__oversized(__alloc_size)) {
                return __oversized_alloc_.__deallocate(__res_, __p);
            } else {
                __pool_buf_[__index_for(__alloc_size)].__deallocate(__res_, __p);
            }
        }

        void __release()
        {
            for (int __i = 0; __i < __num_pools_; ++__i) {
                __pool_buf_[__i].__release(__res_);
            }
            __oversized_alloc_.__release(__res_);
        }

        pool_options __options() const 
        {
            return __opts_;
        }

        memory_resource * __resource() const
        {
            return __res_;
        }
    private:
        void __init()
        {
            for (int __i = 0; __i < __num_pools_; ++__i) {
                __pool_buf_[__i].__init_pool_options(
                    pool_options::__impl_smallest_required_pool_block << __i
                  , __opts_.max_blocks_per_chunk
                  );
            }
        }

    private:
        pool_options __opts_;
        size_t __num_pools_;
        memory_resource * __res_;
        _PoolType __pool_buf_[pool_options::__impl_max_number_pools];
        __monotonic_chunk_allocator __oversized_alloc_;
    };

    class _LIBCPP_TYPE_VIS_ONLY synchronized_pool_resource
      : public memory_resource
    {
    public:
        synchronized_pool_resource(
            pool_options const & __opts, memory_resource * __ustream)
            : __base_(__opts, __ustream)
        {}

        synchronized_pool_resource()
          : synchronized_pool_resource(pool_options(), get_default_resource())
        {}

        explicit synchronized_pool_resource(memory_resource * __ustream)
          : synchronized_pool_resource(pool_options(), __ustream)
        {}

        explicit synchronized_pool_resource(pool_options const & __opts)
          : synchronized_pool_resource(__opts, get_default_resource())
        {}

        synchronized_pool_resource(synchronized_pool_resource const &) = delete;

        virtual ~synchronized_pool_resource() {}

        synchronized_pool_resource & operator=(
            synchronized_pool_resource const &) = delete;


        void release()
        {
            __base_.__release();
        }

        _LIBCPP_ALWAYS_INLINE
        memory_resource * upstream_resource() const
        {
            return __base_.__resource();
        }

        _LIBCPP_ALWAYS_INLINE
        pool_options options() const
        {
            return __base_.__options();
        }

    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align)
        {
            return __base_.__allocate(__bytes, __align);
        }

        virtual void do_deallocate(void * __p, size_t __bytes, size_t __align)
        {
            __base_.__deallocate(__p, __bytes, __align);
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return *__base_.__resource() == __other;
        }

    private:
        typedef __pool_resource_base<__synchronized_memory_pool> _Base;
        _Base __base_;
    };


    class _LIBCPP_TYPE_VIS_ONLY unsynchronized_pool_resource
      : public memory_resource
    {
    public:
        unsynchronized_pool_resource(
            pool_options const & __opts, memory_resource * __ustream)
            : __base_(__opts, __ustream)
        {}

        unsynchronized_pool_resource()
          : unsynchronized_pool_resource(pool_options(), get_default_resource())
        {}

        explicit unsynchronized_pool_resource(memory_resource * __ustream)
          : unsynchronized_pool_resource(pool_options(), __ustream)
        {}

        explicit unsynchronized_pool_resource(pool_options const & __opts)
          : unsynchronized_pool_resource(__opts, get_default_resource())
        {}

        unsynchronized_pool_resource(unsynchronized_pool_resource const &) = delete;

        virtual ~unsynchronized_pool_resource() {}

        unsynchronized_pool_resource & operator=(
            unsynchronized_pool_resource const &) = delete;

        void release()
        {
            __base_.__release();
        }

        _LIBCPP_ALWAYS_INLINE
        memory_resource * upstream_resource() const
        {
            return __base_.__resource();
        }

        _LIBCPP_ALWAYS_INLINE
        pool_options options() const
        {
            return __base_.__options();
        }

    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align)
        {
            return __base_.__allocate(__bytes, __align);
        }

        virtual void do_deallocate(void * __p, size_t __bytes, size_t __align)
        {
            __base_.__deallocate(__p, __bytes, __align);
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return *__base_.__resource() == __other;
        }

    private:
        typedef __pool_resource_base<__memory_pool> _Base;
        _Base __base_;
    };

    class _LIBCPP_TYPE_VIS_ONLY monotonic_buffer_resource
      : public memory_resource
    {
        static const size_t __min_buf_size = 512;
    public:
        explicit monotonic_buffer_resource(memory_resource * __res)
            : __buf_(nullptr)
            , __left_(0)
            , __next_buf_size_(__min_buf_size)
            , __res_(__res)
            , __alloc_()
        {}

        monotonic_buffer_resource(size_t __init_size, memory_resource * __res)
            : __buf_(nullptr)
            , __left_(0)
            , __next_buf_size_(__init_size < __min_buf_size
                            ? __min_buf_size
                            : __round_up_pow_2(__init_size))
            , __res_(__res)
            , __alloc_()
        {}

        monotonic_buffer_resource(void * __buf, size_t __buf_size
                                , memory_resource * __res)
          : monotonic_buffer_resource(__buf_size, __res)
        {
            if (__buf_size <= __monotonic_chunk_allocator::__chunk_node_size) {
                __res_->deallocate(__buf, __buf_size);
            } else {
                __buf_ = __alloc_.__append_chunk(__buf, __buf_size);
                __left_ = __buf_size - (static_cast<char*>(__buf_) - static_cast<char*>(__buf));
            }
        }

        monotonic_buffer_resource()
          : monotonic_buffer_resource(get_default_resource())
        {}

        explicit monotonic_buffer_resource(size_t __init_size)
          : monotonic_buffer_resource(__init_size, get_default_resource())
        {}

        monotonic_buffer_resource(void * __buf, size_t __buf_size)
          : monotonic_buffer_resource(__buf, __buf_size, get_default_resource())
        {}

        monotonic_buffer_resource(monotonic_buffer_resource const &) = delete;

        virtual ~monotonic_buffer_resource() { __alloc_.__release(__res_); }

        monotonic_buffer_resource & operator=(
            monotonic_buffer_resource const &) = delete;

        void release()
        {
            __alloc_.__release(__res_);
        }

        memory_resource * upstream_resource() const _NOEXCEPT
        {
            return __res_;
        }

    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align)
        {
            void * __r = __take_from_buf(__bytes, __align);
            if (__r) { return __r; }
            __alloc_from_upstream(__bytes, __align);
            return __take_from_buf(__bytes, __align);
        }

        virtual void do_deallocate(void *, size_t, size_t)
        {
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return this ==
                dynamic_cast<monotonic_buffer_resource const *>(&__other);
        }

    private:
        void * __take_from_buf(size_t __s, size_t __a)
        {
            void * __next = _VSTD::align(__a, __s, __buf_, __left_);
            if (__next) {
                void * __r = __buf_;
                __buf_ = __next;
                return __r;
            }
        }

        void __alloc_from_upstream(size_t __s, size_t __a)
        {
            size_t const __req_size = _VSTD_LFTS_PMR::__aligned_allocation_size(__s, __a);
            __increment_buf_size(__req_size);
            void * __buf_ = __alloc_.__allocate(__res_, __next_buf_size_);
            __left_ = __next_buf_size_;
        }

        void __increment_buf_size(size_t __s)
        {
            size_t const __possible_next = _VSTD::max(
                __next_buf_size_ << 1
              , __round_up_pow_2(__s)
              );
            __next_buf_size_ = _VSTD::max(__next_buf_size_, __possible_next);
        }

    private:
        void * __buf_;
        size_t __left_;
        size_t __next_buf_size_;
        memory_resource * __res_;
        __monotonic_chunk_allocator __alloc_;
    };

_LIBCPP_END_NAMESPACE_LFTS_PMR

#endif /* _LIBCPP_STD_VER > 11 */

#endif /* _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE */
