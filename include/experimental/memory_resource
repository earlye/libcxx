// -*- C++ -*-
//===------------------------ memory_resource -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE
#define _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE

/**
    experimental/memory_resource synopsis

// C++1y

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
namespace pmr {

  class memory_resource;

  bool operator==(const memory_resource& a,
                  const memory_resource& b) noexcept;
  bool operator!=(const memory_resource& a,
                  const memory_resource& b) noexcept;

  template <class Tp> class polymorphic_allocator;

  template <class T1, class T2>
  bool operator==(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;
  template <class T1, class T2>
  bool operator!=(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;

  // The name resource_adaptor_imp is for exposition only.
  template <class Allocator> class resource_adaptor_imp;

  template <class Allocator>
    using resource_adaptor = resource_adaptor_imp<
      allocator_traits<Allocator>::rebind_alloc<char>>;

  // Global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;

  // The default memory resource
  memory_resource* set_default_resource(memory_resource* r) noexcept;
  memory_resource* get_default_resource() noexcept;

  // Standard memory resources
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;

} // namespace pmr
} // namespace fundamentals_v1
} // namespace experimental
} // namespace std

 */

#include <experimental/__config>
#include <atomic>
#include <mutex>
#include <experimental/__memory>
#include <memory>
#include <new>
#include <type_traits>
#include <tuple>
#include <utility>
#include <cstddef>

#ifdef _LIBCPP_DEBUG
#   include <__debug>
#else
#   define _LIBCPP_ASSERT(x, m) ((void)0)
#endif

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_LFTS_PMR

// 8.5, memory.resource
    class _LIBCPP_TYPE_VIS_ONLY memory_resource
    {
        static constexpr size_t __max_align = alignment_of<max_align_t>::value;

    // 8.5.2, memory.resource.public
    public:
        virtual ~memory_resource();

        _LIBCPP_INLINE_VISIBILITY
        void* allocate(size_t __bytes, size_t __align = __max_align)
        {
            return do_allocate(__bytes, __align);
        }

        _LIBCPP_INLINE_VISIBILITY
        void deallocate(void * __p, size_t __bytes, size_t __align = __max_align)
        {
            do_deallocate(__p, __bytes, __align);
        }

        _LIBCPP_INLINE_VISIBILITY
        bool is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            return do_is_equal(__other);
        }

    // 8.5.3, memory.resource.priv
    protected:
        virtual void* do_allocate(
            size_t __bytes, size_t __align) = 0;

        virtual void do_deallocate(
            void * __p, size_t __bytes, size_t __align) = 0;

        virtual bool do_is_equal(
            memory_resource const & __other) const _NOEXCEPT = 0;
    };

    // 8.5.4, memory.resource.eq

    inline _LIBCPP_INLINE_VISIBILITY
    bool operator==(
        memory_resource const & __lhs
      , memory_resource const & __rhs) _NOEXCEPT
    {
        return &__lhs == &__rhs || __lhs.is_equal(__rhs);
    }

    inline _LIBCPP_INLINE_VISIBILITY
    bool operator!=(
        memory_resource const & __lhs
      , memory_resource const & __rhs) _NOEXCEPT
    {
        return !(__lhs == __rhs);
    }

// 8.6, memory.polymorphic.allocator.class

    // 8.6.1, memory.polymorphic.allocator.overview
    template <class _ValueType>
    class _LIBCPP_TYPE_VIS_ONLY polymorphic_allocator
    {
        memory_resource * __res_;

        template <class _Tuple>
        _LIBCPP_INLINE_VISIBILITY
        _Tuple && __transform_tuple(integral_constant<int, 0>, _Tuple && __t) const
        {
            return _VSTD::forward<_Tuple>(__t);
        }

        template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        tuple<allocator_arg_t, memory_resource*, _Args...>
        __transform_tuple(integral_constant<int, 1>, tuple<_Args...> && __t) const
        {
            return _VSTD::tuple_cat(
                _VSTD::make_tuple(allocator_arg, resource())
              , _VSTD::move(__t)
              );
        }

        template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        tuple<_Args..., memory_resource*>
        __transform_tuple(integral_constant<int, 2>, tuple<_Args...> && __t) const
        {
            return _VSTD::tuple_cat(
                _VSTD::move(__t), _VSTD::make_tuple(resource())
              );
        }

    public:
        typedef _ValueType value_type;

        // 8.6.2, memory.polymorphic.allocator.ctor
        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator() _NOEXCEPT
          : __res_(_VSTD_LFTS_PMR::get_default_resource())
        {}

        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator(memory_resource * __r) _NOEXCEPT
          : __res_(__r)
        {}

        polymorphic_allocator(polymorphic_allocator const &) = default;

        template <class _Tp>
        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator(
            polymorphic_allocator<_Tp> const & __other) _NOEXCEPT
          : __res_(__other.resource())
        {}

        polymorphic_allocator &
        operator=(polymorphic_allocator const &) = default;

        // 8.6.3, memory.polymorphic.allocator.mem
        _LIBCPP_INLINE_VISIBILITY
        _ValueType* allocate(size_t __n)
        {
            return static_cast<_ValueType*>(
                __res_->allocate(__n * sizeof(_ValueType)
                                , alignment_of<_ValueType>::value)
              );
        }

        _LIBCPP_INLINE_VISIBILITY
        void deallocate(_ValueType * __p, size_t __n) _NOEXCEPT
        {
            __res_->deallocate(
                __p, __n * sizeof(_ValueType)
              , alignment_of<_ValueType>::value
              );
        }

        template <class _Tp, class ..._Ts>
        _LIBCPP_INLINE_VISIBILITY
        void construct(_Tp* __p, _Ts &&... __args)
        {
            _VSTD_LFTS::__lfts_user_alloc_construct(
                __p, resource(), _VSTD::forward<_Ts>(__args)...
              );
        }

        template <class _T1, class _T2, class ..._Args1, class ..._Args2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2>* __p, piecewise_construct_t
            , tuple<_Args1...> __x, tuple<_Args2...> __y)
        {
          ::new ((void*)__p) pair<_T1, _T2>(piecewise_construct
            , __transform_tuple(
                typename __lfts_uses_alloc_ctor<
                    _T1, memory_resource*, _Args1...
                >::type()
              , _VSTD::move(__x)
              )
            , __transform_tuple(
                typename __lfts_uses_alloc_ctor<
                    _T2, memory_resource*, _Args2...
                >::type()
              , _VSTD::move(__y)
              )
            );
        }

        template <class _T1, class _T2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2>* __p)
        {
            construct(__p, piecewise_construct, tuple<>(), tuple<>());
        }

        template <class _T1, class _T2, class _Up, class _Vp>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2> * __p, _Up && __u, _Vp && __v)
        {
            construct(__p, piecewise_construct
              , _VSTD::forward_as_tuple(_VSTD::forward<_Up>(__u))
              , _VSTD::forward_as_tuple(_VSTD::forward<_Vp>(__v)));
        }

        template <class _T1, class _T2, class _U1, class _U2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2> * __p, pair<_U1, _U2> const & __pr)
        {
            construct(__p, piecewise_construct
                , _VSTD::forward_as_tuple(__pr.first)
                , _VSTD::forward_as_tuple(__pr.second));
        }

        template <class _T1, class _T2, class _U1, class _U2>
        _LIBCPP_INLINE_VISIBILITY
        void construct(pair<_T1, _T2> * __p, pair<_U1, _U2> && __pr)
        {
            construct(__p, piecewise_construct
                , _VSTD::forward_as_tuple(_VSTD::forward<_U1>(__pr.first))
                , _VSTD::forward_as_tuple(_VSTD::forward<_U2>(__pr.second)));
        }

        template <class _Tp>
        _LIBCPP_INLINE_VISIBILITY
        void destroy(_Tp * __p) _NOEXCEPT
        { __p->~_Tp(); }

        _LIBCPP_INLINE_VISIBILITY
        polymorphic_allocator
        select_on_container_copy_construction() const _NOEXCEPT
        { return polymorphic_allocator(); }

        _LIBCPP_INLINE_VISIBILITY
        memory_resource * resource() const _NOEXCEPT
        { return __res_; }
    };

    // 8.6.4, memory.polymorphic.allocator.eq

    template <class _Tp, class _Up>
    inline _LIBCPP_INLINE_VISIBILITY
    bool operator==(
        polymorphic_allocator<_Tp> const & __lhs
      , polymorphic_allocator<_Up> const & __rhs) _NOEXCEPT
    {
        return *__lhs.resource() == *__rhs.resource();
    }

    template <class _Tp, class _Up>
    inline _LIBCPP_INLINE_VISIBILITY
    bool operator!=(
        polymorphic_allocator<_Tp> const & __lhs
      , polymorphic_allocator<_Up> const & __rhs) _NOEXCEPT
    {
        return !(__lhs == __rhs);
    }

// 8.7, memory.resource.adaptor

    // 8.7.1, memory.resource.adaptor.overview
    template <class _Alloc> 
    class _LIBCPP_TYPE_VIS_ONLY __resource_adaptor_imp
      : public memory_resource
    {
        _Alloc __alloc_;
        typedef allocator_traits<_Alloc> _Traits;
        typedef typename _Traits::value_type _ValueType;
        typedef typename _Traits::pointer _Pointer;

        static_assert(
            is_same<_ValueType, char>::value
          , "value_type must be char"
          );

    public:
        typedef _Alloc allocator_type;

        __resource_adaptor_imp() = default;
        __resource_adaptor_imp(__resource_adaptor_imp const &) = default;
        __resource_adaptor_imp(__resource_adaptor_imp &&) = default;

        // 8.7.2, memory.resource.adaptor.ctor

        _LIBCPP_INLINE_VISIBILITY
        explicit __resource_adaptor_imp(_Alloc const & __a)
          : __alloc_(__a)
        {}

        _LIBCPP_INLINE_VISIBILITY
        explicit __resource_adaptor_imp(_Alloc && __a)
          : __alloc_(_VSTD::move(__a))
        {}

        __resource_adaptor_imp &
        operator=(__resource_adaptor_imp const &) = default;

        _LIBCPP_INLINE_VISIBILITY
        allocator_type get_allocator() const
        { return __alloc_; }

    // 8.7.3, memory.resource.adaptor.mem
    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align)
        {
            return _Traits::allocate(
                __alloc_, __aligned_allocation_size(__bytes, __align)
              );
        }

        virtual void do_deallocate(void * __p, size_t __bytes, size_t __align)
        {
            _Traits::deallocate(
                __alloc_, static_cast<_Pointer>(__p)
              , __aligned_allocation_size(__bytes, __align)
              );
        }

        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT
        {
            __resource_adaptor_imp const * __p
              = dynamic_cast<__resource_adaptor_imp const *>(&__other);
            return __p  ? __alloc_ == __p->__alloc_ : false;
        }
    };

    _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __resource_adaptor_imp<allocator<char>>)

    template <class _Alloc>
    using resource_adaptor
        = __resource_adaptor_imp<
            typename allocator_traits<_Alloc>::template rebind_alloc<char>
        >;


    class _LIBCPP_TYPE_VIS_ONLY __new_delete_memory_resource_imp 
        : public memory_resource
    {
    public:
        ~__new_delete_memory_resource_imp();
    protected:
        virtual void* do_allocate(size_t __size, size_t __align);
        virtual void do_deallocate(void * __p, size_t __size, size_t __align);
        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT;
    };

    class _LIBCPP_TYPE_VIS_ONLY __null_memory_resource_imp
        : public memory_resource
    {
    public:
        ~__null_memory_resource_imp();
    protected:
        virtual void* do_allocate(size_t, size_t);
        virtual void do_deallocate(void *, size_t, size_t);
        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT;
    };

    _LIBCPP_FUNC_VIS
    memory_resource * new_delete_resource() _NOEXCEPT;

    _LIBCPP_FUNC_VIS
    memory_resource * null_memory_resource() _NOEXCEPT;

    _LIBCPP_FUNC_VIS
    atomic<memory_resource*> * __default_memory_resource() _NOEXCEPT;

    inline _LIBCPP_INLINE_VISIBILITY
    memory_resource * set_default_resource(memory_resource * __r) _NOEXCEPT
    {
        memory_resource * __new = __r  ? __r : new_delete_resource();
        return _VSTD::atomic_exchange(__default_memory_resource(), __new);
    }

    inline _LIBCPP_INLINE_VISIBILITY
    memory_resource * get_default_resource() _NOEXCEPT
    {
        return _VSTD::atomic_load(__default_memory_resource());
    }

    struct _LIBCPP_TYPE_VIS_ONLY pool_options
    {
        size_t max_blocks_per_chunk = 0;
        size_t largest_required_pool_block = 0;

        // Implementation limits
        static const size_t __impl_max_blocks_per_chunk = 32;
        static const size_t __impl_smallest_required_pool_block = 8;
        static const size_t __impl_largest_required_pool_block = 4096;
    };

    inline _LIBCPP_INLINE_VISIBILITY
    pool_options __adjust_pool_options(pool_options __opts) _NOEXCEPT
    {
        __opts.max_blocks_per_chunk = __opts.max_blocks_per_chunk
                && __opts.max_blocks_per_chunk < pool_options::__impl_max_blocks_per_chunk
                ? __opts.max_blocks_per_chunk : pool_options::__impl_max_blocks_per_chunk;

        __opts.largest_required_pool_block = __opts.largest_required_pool_block
            && __opts.largest_required_pool_block < pool_options::__impl_largest_required_pool_block
            ? ( __opts.largest_required_pool_block < pool_options::__impl_smallest_required_pool_block
                ? pool_options::__impl_smallest_required_pool_block
                : __opts.largest_required_pool_block)
            : pool_options::__impl_largest_required_pool_block;

        return __opts;
    }

    struct __double_linked_chunk_node
    {
        __double_linked_chunk_node * __next_;
        __double_linked_chunk_node ** __prev_next_addr_;
        size_t __size_;
        max_align_t __memory_;

        static void __push(__double_linked_chunk_node ** __head_ptr, __double_linked_chunk_node * __n);
        static void __remove(__double_linked_chunk_node **, __double_linked_chunk_node * __n);
    };

    struct __single_linked_chunk_node
    {
        __single_linked_chunk_node * __next_;
        size_t __size_;
        max_align_t __memory_;

        static void __push(__single_linked_chunk_node ** __head_ptr, __single_linked_chunk_node * __n);
        static void __remove(__single_linked_chunk_node ** __head_ptr, __single_linked_chunk_node * __n);
    };

    template <class _ChunkNode>
    class __basic_chunk_allocator
    {
        static_assert(
            is_standard_layout<_ChunkNode>::value
          , "_ChunkNode must be standard layout"
          );

        static _ChunkNode * __memory_to_chunk(void * __p)
        {
            return static_cast<_ChunkNode*>(static_cast<void*>(
                static_cast<char*>(__p) - offsetof(_ChunkNode, __memory_)
            ));
        }

    public:
        static const size_t __chunk_node_size = sizeof(_ChunkNode);

        static size_t __offset_of_memory()
        {
            return offsetof(_ChunkNode, __memory_);
        }

    public:
        explicit __basic_chunk_allocator()
            : __head_(nullptr)
        {}

        __basic_chunk_allocator(__basic_chunk_allocator const &) = delete;

        __basic_chunk_allocator & operator=(__basic_chunk_allocator const &) = delete;

        void * __allocate(memory_resource * __res, size_t __s)
        {
            if (! __s) {
                return nullptr;
            }
            const size_t __alloc_size = sizeof(_ChunkNode) + __s;
            return __make_chunk(__res->allocate(__alloc_size), __alloc_size);
        }

        void __deallocate(memory_resource * __res, void * __p) _NOEXCEPT 
        {
            if (! __p) {
                return;
            }
            _ChunkNode * const __n = __memory_to_chunk(__p);
            _ChunkNode::__remove(&__head_, __n);
            __res->deallocate(__n, __n->__size_);
        }

        void __release(memory_resource * __res) _NOEXCEPT
        {
            while (__head_) {
                _ChunkNode * const __block = __head_;
                __head_ = __block->__next_;
                __res->deallocate(__block, __block->__size_);
            }
        }

        void * __make_chunk(void * __p, size_t __s) _NOEXCEPT
        {
            _ChunkNode * const __n = static_cast<_ChunkNode*>(__p);
            __n->__size_ = __s;
            _ChunkNode::__push(&__head_, __n);
            return static_cast<void*>(&__n->__memory_);
        }

    private:
        _ChunkNode * __head_;
    };

    typedef __basic_chunk_allocator<__double_linked_chunk_node> __chunk_allocator;
    typedef __basic_chunk_allocator<__single_linked_chunk_node> __single_linked_chunk_allocator;

    _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_chunk_allocator<__double_linked_chunk_node>)
    _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_chunk_allocator<__single_linked_chunk_node>)


#ifdef _LIBCPP_CLEVER_MEMORY_POOL
    template <size_t _Size>
    struct __memory_resource_chunk
    {
        void *__original_ptr_;
        __memory_resource_chunk *__next_free_chunk_;
        __memory_resource_chunk *__next_chunk_;
        uint8_t __num_free_;
        uint8_t __next_free_;
    }

    struct __clever_memory_pool
    {
        size_t blocks_per_chunk() {
            return pool_options.max_blocks_per_chunk < 256 ?
                pool_options.max_blocks_per_chunk : 256;
        }
        void *free_list_head;
        void *chunk_list_head;
        void *get_block(memory_resource *upstream) {
            if (this->free_list_head == NULL) {
                size_t blocks = this->blocks_per_chunk();
                size_t alignment = blocks * _Size;

                void *unaligned = upstream->do_allocate(2 * alignment, 0);
                void *aligned = unaligned / alignment;
                aligned += unaligned % alignment > 0 ? alignment : 0;

                struct __memory_resource_chunk *chunk = aligned;
                chunk->__original_ptr_ = unaligned;
                chunk->__num_free_ = (alignment - sizeof(__memory_resource_chunk)) / _Size;
                // TODO: optimize this by pushing us to the tail
                chunk->__next_free_chunk = this->free_list_head;
                chunk->__next_chunk = this->chunk_list_head;
                this->free_list_head = aligned;
                this->chunk_list_head = aligned;
            }
            struct __memory_resource_chunk *chunk = this->free_list_head;
            size_t chunk_struct_size = sizeof(__memory_resource_chunk);
            size_t chunk_header_size = chunk_struct_size / _Size;
            chunk_header_size += chunk_struct_size % _Size > 0 ? 1 : 0;
            uint8_t *block = (uint8_t *)chunk + _Size * (chunk->__next_free__ + chunk_header_size);
            if (--chunk->__num_free__ == 0) {
                this->free_list_head = chunk->__next_free_chunk__;
            }
            chunk->__next_free__ = *block;
            return block;
        }
        void return_block(void *block_raw) {
            uint8_t *block = (uint8_t *)block_raw;
            size_t blocks = this->blocks_per_chunk();
            size_t alignment = blocks * _Size;
            void *aligned = block / alignment;

            struct __memory_resource_chunk *chunk = aligned;
            if (++chunk->__num_free__ == 1) {
                chunk->__next_free_chunk__ = this->free_list_head;
                this->free_list_head = chunk;
            }

            uint8_t max_free = (alignment - sizeof(__memory_resource_chunk)) / _Size;
            if (++chunk->__num_free__ == max_free) {
                // Dealloc chunk?
            }

            uint8_t block_index = block % alignment;
            *block = chunk->__next_free__;
            chunk->__next_free__ = block_index;
        }
    };
#endif

    class _LIBCPP_TYPE_VIS_ONLY __memory_pool
    {
        struct __block_node
        {
            __block_node * __next_;
        };
    public:
        __memory_pool()
            : __block_size_(0)
            , __chunk_size_(1)
            , __max_block_per_chunk_(0)
            , __free_head_(nullptr)
            , __alloc_()
        {}

        __memory_pool(size_t __bsize, size_t __max_cs)
            : __block_size_(__bsize)
            , __chunk_size_(1)
            , __max_block_per_chunk_(__max_cs)
            , __free_head_(nullptr)
            , __alloc_()
        {}

        __memory_pool(__memory_pool const &) = delete;

        void * __allocate(memory_resource * __res);
        void __deallocate(memory_resource *, void * __p);
        void __release(memory_resource * __res);

        _LIBCPP_INLINE_VISIBILITY
        void __init_pool_options(size_t __block_size, size_t __max_blocks)
        {
            __block_size_ = __block_size;
            __max_block_per_chunk_ = __max_blocks;
        }

    private:
        void __alloc_new_chunk(memory_resource * __res);
        void __add_chunk_to_free_list(void * __p, size_t __s, size_t __a);
        void __increment_max_blocks_per_chunk();

    private:
        size_t __block_size_;
        size_t __chunk_size_;
        size_t __max_block_per_chunk_;
        __block_node * __free_head_;
        __single_linked_chunk_allocator __alloc_;
    };

    class _LIBCPP_TYPE_VIS_ONLY __synchronized_memory_pool
    {
    public:
        __synchronized_memory_pool()
            : __pool_()
        {}

        __synchronized_memory_pool(size_t __bsize, size_t __max_cs)
            : __pool_(__bsize, __max_cs)
        {}

        __synchronized_memory_pool(__synchronized_memory_pool const &) = delete;
        __synchronized_memory_pool & operator=(__synchronized_memory_pool const &) = delete;

        _LIBCPP_INLINE_VISIBILITY
        void * __allocate(memory_resource * __res)
        {
            lock_guard<mutex> __guard(__lock_);
            return __pool_.__allocate(__res);
        }

        _LIBCPP_INLINE_VISIBILITY
        void __deallocate(memory_resource * __res, void * __p) 
        {
            lock_guard<mutex> __guard(__lock_);
            __pool_.__deallocate(__res, __p);
        }

        _LIBCPP_INLINE_VISIBILITY
        void __release(memory_resource * __res)
        {
            lock_guard<mutex> __guard(__lock_);
            __pool_.__release(__res);
        }

        _LIBCPP_INLINE_VISIBILITY
        void __init_pool_options(size_t __block_size, size_t __max_block_per_chunk)
        {
            __pool_.__init_pool_options(__block_size, __max_block_per_chunk);
        }

    private:
        mutex __lock_;
        __memory_pool __pool_;
    };


    template <class _PoolType>
    class _LIBCPP_TYPE_VIS_ONLY __pool_resource_base
    {
        // Enough for pools with sizes:
        // 8, 16, 32, 64, 128, 256, 512, 1024, 2056, 4096
        // Assumes min/max pool size is known.
        static const size_t __max_num_pools = 10;

        static_assert(
            pool_options::__impl_smallest_required_pool_block == 8
          , "Expected smallest pool size to be 8"
          );
        static_assert(
            pool_options::__impl_largest_required_pool_block == 4096
            ,"Expected largest pool size to be 4096"
            );

        _LIBCPP_INLINE_VISIBILITY
        static size_t __index_of(size_t __pow) _NOEXCEPT
        {
            // 36 is used instead of 32 so that indexes start at 8.
            return 36 - _VSTD_LFTS::__count_leading_zeros(__pow);
        }

        _LIBCPP_INLINE_VISIBILITY
        bool __undersized(size_t __s) const _NOEXCEPT
        {
            return __s < pool_options::__impl_smallest_required_pool_block;
        }

        _LIBCPP_INLINE_VISIBILITY
        bool __oversized(size_t __s) const _NOEXCEPT
        {
            return __s > __opts_.largest_required_pool_block;
        }

        /// Precondition: __s <= largest_required_pool_block
        _LIBCPP_INLINE_VISIBILITY
        size_t __index_for(size_t __s) const _NOEXCEPT
        {
            return __undersized(__s) ? 0 : __index_of(__round_up_pow_2(__s));
        }

    public:

        __pool_resource_base(pool_options __opts, memory_resource * __res)
            : __opts_(__adjust_pool_options(__opts))
            , __num_pools_(__index_of(__opts_.largest_required_pool_block))
            , __res_(__res)
        {
            for (int __i = 0; __i < __num_pools_; ++__i) {
                __pool_buf_[__i].__init_pool_options(
                    pool_options::__impl_smallest_required_pool_block << __i
                  , __opts_.max_blocks_per_chunk
                  );
            }
        }

        __pool_resource_base(__pool_resource_base const &) = delete;

        ~__pool_resource_base()
        {
            __release();
        }

        __pool_resource_base & operator=(__pool_resource_base const &) = delete;

        void * __allocate(size_t __s, size_t __a)
        {
            size_t const __alloc_size = __aligned_allocation_size(__s, __a);
            if (__oversized(__alloc_size)) {
                return __oversized_alloc_.__allocate(__res_, __alloc_size);
            } else {
                return __pool_buf_[__index_for(__alloc_size)].__allocate(__res_);
            }
        }

        void __deallocate(void * __p, size_t __s, size_t __a) _NOEXCEPT
        {
            size_t const __alloc_size = __aligned_allocation_size(__s, __a);
            if (__oversized(__alloc_size)) {
                return __oversized_alloc_.__deallocate(__res_, __p);
            } else {
                __pool_buf_[__index_for(__alloc_size)].__deallocate(__res_, __p);
            }
        }

        void __release() _NOEXCEPT
        {
            for (int __i = 0; __i < __num_pools_; ++__i) {
                __pool_buf_[__i].__release(__res_);
            }
            __oversized_alloc_.__release(__res_);
        }

        _LIBCPP_INLINE_VISIBILITY
        pool_options __options() const _NOEXCEPT
        {
            return __opts_;
        }

        _LIBCPP_INLINE_VISIBILITY
        memory_resource * __resource() const _NOEXCEPT
        {
            return __res_;
        }

    private:
        pool_options __opts_;
        size_t __num_pools_;
        memory_resource * __res_;
        _PoolType __pool_buf_[__max_num_pools];
        __chunk_allocator __oversized_alloc_;
    };

    class _LIBCPP_TYPE_VIS_ONLY synchronized_pool_resource
      : public memory_resource
    {
    public:
        synchronized_pool_resource(
            pool_options const & __opts, memory_resource * __ustream)
            : __base_(__opts, __ustream)
        {}

        synchronized_pool_resource()
          : synchronized_pool_resource(pool_options(), get_default_resource())
        {}

        explicit synchronized_pool_resource(memory_resource * __ustream)
          : synchronized_pool_resource(pool_options(), __ustream)
        {}

        explicit synchronized_pool_resource(pool_options const & __opts)
          : synchronized_pool_resource(__opts, get_default_resource())
        {}

        synchronized_pool_resource(synchronized_pool_resource const &) = delete;

        virtual ~synchronized_pool_resource();

        synchronized_pool_resource & operator=(
            synchronized_pool_resource const &) = delete;

        _LIBCPP_INLINE_VISIBILITY
        void release()
        {
            __base_.__release();
        }

        _LIBCPP_INLINE_VISIBILITY
        memory_resource * upstream_resource() const
        {
            return __base_.__resource();
        }

        _LIBCPP_INLINE_VISIBILITY
        pool_options options() const
        {
            return __base_.__options();
        }

    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align);
        virtual void do_deallocate(void * __p, size_t __bytes, size_t __align);
        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT;

    private:
        typedef __pool_resource_base<__synchronized_memory_pool> _Base;
        _Base __base_;
    };


    class _LIBCPP_TYPE_VIS_ONLY unsynchronized_pool_resource
      : public memory_resource
    {
    public:
        unsynchronized_pool_resource(
            pool_options const & __opts, memory_resource * __ustream)
            : __base_(__opts, __ustream)
        {}

        unsynchronized_pool_resource()
          : unsynchronized_pool_resource(pool_options(), get_default_resource())
        {}

        explicit unsynchronized_pool_resource(memory_resource * __ustream)
          : unsynchronized_pool_resource(pool_options(), __ustream)
        {}

        explicit unsynchronized_pool_resource(pool_options const & __opts)
          : unsynchronized_pool_resource(__opts, get_default_resource())
        {}

        unsynchronized_pool_resource(unsynchronized_pool_resource const &) = delete;

        virtual ~unsynchronized_pool_resource();

        unsynchronized_pool_resource & operator=(
            unsynchronized_pool_resource const &) = delete;

        _LIBCPP_INLINE_VISIBILITY
        void release()
        {
            __base_.__release();
        }

        _LIBCPP_INLINE_VISIBILITY
        memory_resource * upstream_resource() const
        {
            return __base_.__resource();
        }

        _LIBCPP_INLINE_VISIBILITY
        pool_options options() const
        {
            return __base_.__options();
        }

    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align);
        virtual void do_deallocate(void * __p, size_t __bytes, size_t __align);
        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT;

    private:
        typedef __pool_resource_base<__memory_pool> _Base;
        _Base __base_;
    };

    class _LIBCPP_TYPE_VIS_ONLY monotonic_buffer_resource
      : public memory_resource
    {
        static const size_t __min_buf_size = 512;
    public:
        explicit monotonic_buffer_resource(memory_resource * __res)
            : __buf_(nullptr)
            , __left_(0)
            , __next_buf_size_(__min_buf_size)
            , __res_(__res)
        {}

        monotonic_buffer_resource(size_t __init_size, memory_resource * __res)
            : __buf_(nullptr)
            , __left_(0)
            , __next_buf_size_(__init_size < __min_buf_size
                            ? __min_buf_size
                            : __round_up_pow_2(__init_size))
            , __res_(__res)
        {}

        monotonic_buffer_resource(void * __buf, size_t __buf_size
                                , memory_resource * __res)
          : monotonic_buffer_resource(__buf_size, __res)
        {
            if (__buf_size <= __chunk_allocator::__chunk_node_size) {
                __res_->deallocate(__buf, __buf_size);
            } else {
                __buf_ = __alloc_.__make_chunk(__buf, __buf_size);
                __left_ = __buf_size - __single_linked_chunk_allocator::__offset_of_memory();
            }
        }

        monotonic_buffer_resource()
          : monotonic_buffer_resource(get_default_resource())
        {}

        explicit monotonic_buffer_resource(size_t __init_size)
          : monotonic_buffer_resource(__init_size, get_default_resource())
        {}

        monotonic_buffer_resource(void * __buf, size_t __buf_size)
          : monotonic_buffer_resource(__buf, __buf_size, get_default_resource())
        {}

        monotonic_buffer_resource(monotonic_buffer_resource const &) = delete;

        virtual ~monotonic_buffer_resource();

        monotonic_buffer_resource & operator=(
            monotonic_buffer_resource const &) = delete;

        _LIBCPP_INLINE_VISIBILITY
        void release()
        {
            __alloc_.__release(__res_);
        }

        _LIBCPP_INLINE_VISIBILITY
        memory_resource * upstream_resource() const _NOEXCEPT
        {
            return __res_;
        }

    protected:
        virtual void * do_allocate(size_t __bytes, size_t __align);
        virtual void do_deallocate(void *, size_t, size_t);
        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT;

    private:
        void * __take_from_buf(size_t __s, size_t __a);
        void __alloc_from_upstream(size_t __s, size_t __a);
        void __increment_buf_size(size_t __s);

    private:
        void * __buf_;
        size_t __left_;
        size_t __next_buf_size_;
        memory_resource * __res_;
        __single_linked_chunk_allocator __alloc_;
    };

_LIBCPP_END_NAMESPACE_LFTS_PMR

#endif /* _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE */
