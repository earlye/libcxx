// -*- C++ -*-
//===------------------------ memory_resource -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE
#define _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE

/**
    experimental/memory_resource synopsis

// C++1y

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
namespace pmr {

  class memory_resource;

  bool operator==(const memory_resource& a,
                  const memory_resource& b) noexcept;
  bool operator!=(const memory_resource& a,
                  const memory_resource& b) noexcept;

  template <class Tp> class polymorphic_allocator;

  template <class T1, class T2>
  bool operator==(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;
  template <class T1, class T2>
  bool operator!=(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;

  // The name resource_adaptor_imp is for exposition only.
  template <class Allocator> class resource_adaptor_imp;

  template <class Allocator>
    using resource_adaptor = resource_adaptor_imp<
      allocator_traits<Allocator>::rebind_alloc<char>>;

  // Global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;

  // The default memory resource
  memory_resource* set_default_resource(memory_resource* r) noexcept;
  memory_resource* get_default_resource() noexcept;

  // Standard memory resources
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;

} // namespace pmr
} // namespace fundamentals_v1
} // namespace experimental
} // namespace std

 */

#include <experimental/__config>
#include <experimental/__memory>
#include <limits>
#include <memory>
#include <new>
#include <stdexcept>
#include <tuple>
#include <type_traits>
#include <utility>
#include <cstddef>
#include <cstdlib>
#include <__debug>

#include <cassert> // FIXME remove all usages of assert

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_LFTS_PMR

// 8.5, memory.resource
class _LIBCPP_TYPE_VIS_ONLY memory_resource
{

// 8.5.2, memory.resource.public
public:
    virtual ~memory_resource() = default;

    _LIBCPP_INLINE_VISIBILITY
    void* allocate(size_t __bytes, size_t __align = __max_align())
        { return do_allocate(__bytes, __align); }

    _LIBCPP_INLINE_VISIBILITY
    void deallocate(void * __p, size_t __bytes, size_t __align = __max_align())
        { do_deallocate(__p, __bytes, __align); }

    _LIBCPP_INLINE_VISIBILITY
    bool is_equal(memory_resource const & __other) const _NOEXCEPT
        { return do_is_equal(__other); }

// 8.5.3, memory.resource.priv
protected:
    virtual void* do_allocate(size_t, size_t) = 0;
    virtual void do_deallocate(void*, size_t, size_t) = 0;
    virtual bool do_is_equal(memory_resource const &) const _NOEXCEPT = 0;
};

// 8.5.4, memory.resource.eq
inline _LIBCPP_INLINE_VISIBILITY
bool operator==(memory_resource const & __lhs,
                memory_resource const & __rhs) _NOEXCEPT
{
    return &__lhs == &__rhs || __lhs.is_equal(__rhs);
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(memory_resource const & __lhs,
                memory_resource const & __rhs) _NOEXCEPT
{
    return !(__lhs == __rhs);
}

_LIBCPP_FUNC_VIS
memory_resource * new_delete_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource * null_memory_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource * get_default_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource * set_default_resource(memory_resource * __new_res) _NOEXCEPT;

// 8.6, memory.polymorphic.allocator.class

// 8.6.1, memory.polymorphic.allocator.overview
template <class _ValueType>
class _LIBCPP_TYPE_VIS_ONLY polymorphic_allocator
{
public:
    typedef _ValueType value_type;

    // 8.6.2, memory.polymorphic.allocator.ctor
    _LIBCPP_INLINE_VISIBILITY
    polymorphic_allocator() _NOEXCEPT
      : __res_(_VSTD_LFTS_PMR::get_default_resource())
    {}

    _LIBCPP_INLINE_VISIBILITY
    polymorphic_allocator(memory_resource * __r) _NOEXCEPT
      : __res_(__r)
    {}

    polymorphic_allocator(polymorphic_allocator const &) = default;

    template <class _Tp>
    _LIBCPP_INLINE_VISIBILITY
    polymorphic_allocator(polymorphic_allocator<_Tp> const & __other) _NOEXCEPT
      : __res_(__other.resource())
    {}

    polymorphic_allocator &
    operator=(polymorphic_allocator const &) = delete;

    // 8.6.3, memory.polymorphic.allocator.mem
    _LIBCPP_INLINE_VISIBILITY
    _ValueType* allocate(size_t __n) {
        if (__n > max_size()) {
            __throw_length_error(
                "std::experimental::pmr::polymorphic_allocator<T>::allocate(size_t n)"
                " 'n' exceeds maximum supported size");
        }
        return static_cast<_ValueType*>(
            __res_->allocate(__n * sizeof(_ValueType), alignof(_ValueType))
        );
    }

    _LIBCPP_INLINE_VISIBILITY
    void deallocate(_ValueType * __p, size_t __n) _NOEXCEPT {
        _LIBCPP_ASSERT(__n <= max_size(),
                       "deallocate called for size which exceeds max_size()");
        __res_->deallocate(__p, __n * sizeof(_ValueType), alignof(_ValueType));
    }

    template <class _Tp, class ..._Ts>
    _LIBCPP_INLINE_VISIBILITY
    void construct(_Tp* __p, _Ts &&... __args)
    {
        _VSTD_LFTS::__lfts_user_alloc_construct(
            __p, resource(), _VSTD::forward<_Ts>(__args)...
          );
    }

    template <class _T1, class _T2, class ..._Args1, class ..._Args2>
    _LIBCPP_INLINE_VISIBILITY
    void construct(pair<_T1, _T2>* __p, piecewise_construct_t,
                   tuple<_Args1...> __x, tuple<_Args2...> __y)
    {
        ::new ((void*)__p) pair<_T1, _T2>(piecewise_construct
          , __transform_tuple(
              typename __lfts_uses_alloc_ctor<
                  _T1, memory_resource*, _Args1...
              >::type()
            , _VSTD::move(__x)
            , typename __make_tuple_indices<sizeof...(_Args1)>::type{}
          )
          , __transform_tuple(
              typename __lfts_uses_alloc_ctor<
                  _T2, memory_resource*, _Args2...
              >::type()
            , _VSTD::move(__y)
            , typename __make_tuple_indices<sizeof...(_Args2)>::type{}
          )
        );
    }

    template <class _T1, class _T2>
    _LIBCPP_INLINE_VISIBILITY
    void construct(pair<_T1, _T2>* __p) {
        construct(__p, piecewise_construct, tuple<>(), tuple<>());
    }

    template <class _T1, class _T2, class _Up, class _Vp>
    _LIBCPP_INLINE_VISIBILITY
    void construct(pair<_T1, _T2> * __p, _Up && __u, _Vp && __v) {
        construct(__p, piecewise_construct
          , _VSTD::forward_as_tuple(_VSTD::forward<_Up>(__u))
          , _VSTD::forward_as_tuple(_VSTD::forward<_Vp>(__v)));
    }

    template <class _T1, class _T2, class _U1, class _U2>
    _LIBCPP_INLINE_VISIBILITY
    void construct(pair<_T1, _T2> * __p, pair<_U1, _U2> const & __pr) {
        construct(__p, piecewise_construct
            , _VSTD::forward_as_tuple(__pr.first)
            , _VSTD::forward_as_tuple(__pr.second));
    }

    template <class _T1, class _T2, class _U1, class _U2>
    _LIBCPP_INLINE_VISIBILITY
    void construct(pair<_T1, _T2> * __p, pair<_U1, _U2> && __pr){
        construct(__p, piecewise_construct
            , _VSTD::forward_as_tuple(_VSTD::forward<_U1>(__pr.first))
            , _VSTD::forward_as_tuple(_VSTD::forward<_U2>(__pr.second)));
    }

    template <class _Tp>
    _LIBCPP_INLINE_VISIBILITY
    void destroy(_Tp * __p) _NOEXCEPT
        { __p->~_Tp(); }

    _LIBCPP_INLINE_VISIBILITY
    size_t max_size() const _NOEXCEPT
        { return numeric_limits<size_t>::max() / sizeof(value_type); }

    _LIBCPP_INLINE_VISIBILITY
    polymorphic_allocator
    select_on_container_copy_construction() const _NOEXCEPT
        { return polymorphic_allocator(); }

    _LIBCPP_INLINE_VISIBILITY
    memory_resource * resource() const _NOEXCEPT
        { return __res_; }

private:
    template <class ..._Args, size_t ..._Idx>
    _LIBCPP_INLINE_VISIBILITY
    tuple<_Args&&...>
    __transform_tuple(integral_constant<int, 0>, tuple<_Args...>&& __t,
                      __tuple_indices<_Idx...>) const
    {
        return _VSTD::forward_as_tuple(_VSTD::get<_Idx>(_VSTD::move(__t))...);
    }

    template <class ..._Args, size_t ..._Idx>
    _LIBCPP_INLINE_VISIBILITY
    tuple<allocator_arg_t const&, memory_resource*, _Args&&...>
    __transform_tuple(integral_constant<int, 1>, tuple<_Args...> && __t,
                      __tuple_indices<_Idx...>) const
    {
        using _Tup = tuple<allocator_arg_t const&, memory_resource*, _Args&&...>;
        return _Tup(allocator_arg, resource(),
                    _VSTD::get<_Idx>(_VSTD::move(__t))...);
    }

    template <class ..._Args, size_t ..._Idx>
    _LIBCPP_INLINE_VISIBILITY
    tuple<_Args&&..., memory_resource*>
    __transform_tuple(integral_constant<int, 2>, tuple<_Args...> && __t,
                      __tuple_indices<_Idx...>) const
    {
        using _Tup = tuple<_Args&&..., memory_resource*>;
        return _Tup(_VSTD::get<_Idx>(_VSTD::move(__t))..., resource());
    }

    memory_resource * __res_;
};

// 8.6.4, memory.polymorphic.allocator.eq

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY
bool operator==(polymorphic_allocator<_Tp> const & __lhs,
                polymorphic_allocator<_Up> const & __rhs) _NOEXCEPT
{
    return *__lhs.resource() == *__rhs.resource();
}

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(polymorphic_allocator<_Tp> const & __lhs,
                polymorphic_allocator<_Up> const & __rhs) _NOEXCEPT
{
    return !(__lhs == __rhs);
}

// 8.7, memory.resource.adaptor

// 8.7.1, memory.resource.adaptor.overview
template <class _CharAlloc>
class _LIBCPP_TYPE_VIS_ONLY __resource_adaptor_imp
  : public memory_resource
{
    using _CTraits = allocator_traits<_CharAlloc>;
    static_assert(is_same<typename _CTraits::value_type, char>::value
               && is_same<typename _CTraits::pointer, char*>::value
               && is_same<typename _CTraits::void_pointer, void*>::value, "");

    using _Alloc = typename _CTraits::template rebind_alloc<
            typename aligned_storage<__max_align(), __max_align()>::type
        >;

    using _ValueType = typename _Alloc::value_type;

    _Alloc __alloc_;

public:
    typedef _CharAlloc allocator_type;

    __resource_adaptor_imp() = default;
    __resource_adaptor_imp(__resource_adaptor_imp const &) = default;
    __resource_adaptor_imp(__resource_adaptor_imp &&) = default;

    // 8.7.2, memory.resource.adaptor.ctor

    _LIBCPP_INLINE_VISIBILITY
    explicit __resource_adaptor_imp(allocator_type const & __a)
      : __alloc_(__a)
    {}

    _LIBCPP_INLINE_VISIBILITY
    explicit __resource_adaptor_imp(allocator_type && __a)
      : __alloc_(_VSTD::move(__a))
    {}

    __resource_adaptor_imp &
    operator=(__resource_adaptor_imp const &) = default;

    _LIBCPP_INLINE_VISIBILITY
    allocator_type get_allocator() const
    { return __alloc_; }

// 8.7.3, memory.resource.adaptor.mem
protected:
    virtual void * do_allocate(size_t __bytes, size_t)
    {
        if (__bytes > __max_size()) {
            __throw_length_error(
                "std::experimental::pmr::resource_adaptor<T>::do_allocate(size_t bytes, size_t align)"
                " 'bytes' exceeds maximum supported size");
        }
        size_t __s = __aligned_allocation_size(__bytes) / __max_align();
        return __alloc_.allocate(__s);
    }

    virtual void do_deallocate(void * __p, size_t __bytes, size_t)
    {
        _LIBCPP_ASSERT(__bytes <= __max_size(),
            "do_deallocate called for size which exceeds the maximum allocation size");
        size_t __s = __aligned_allocation_size(__bytes) / __max_align();
        __alloc_.deallocate((_ValueType*)__p, __s);
    }

    virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT {
        __resource_adaptor_imp const * __p
          = dynamic_cast<__resource_adaptor_imp const *>(&__other);
        return __p  ? __alloc_ == __p->__alloc_ : false;
    }

private:
    _LIBCPP_INLINE_VISIBILITY
    size_t __max_size() const _NOEXCEPT {
        return numeric_limits<size_t>::max() - __max_align();
    }
};

template <class _Alloc>
using resource_adaptor = __resource_adaptor_imp<
    typename allocator_traits<_Alloc>::template rebind_alloc<char>
  >;

struct _LIBCPP_TYPE_VIS_ONLY pool_options {
  size_t max_blocks_per_chunk = 0;
  size_t largest_required_pool_block = 0;

  // Implementation limits
  static constexpr size_t __impl_max_blocks_per_chunk = 32;
  static constexpr size_t __impl_smallest_block = 8;
  static constexpr size_t __impl_largest_block = 4096;
};

inline _LIBCPP_INLINE_VISIBILITY size_t
    __adjust_max_blocks_per_chunk(size_t __mbpc) _NOEXCEPT {
  if (__mbpc == 0 || __mbpc > pool_options::__impl_max_blocks_per_chunk) {
    return pool_options::__impl_max_blocks_per_chunk;
  } else {
    return __mbpc;
  }
}

inline _LIBCPP_INLINE_VISIBILITY size_t
    __adjust_largest_required_pool_block(size_t __lpb) _NOEXCEPT {
  if (__lpb == 0 || __lpb > pool_options::__impl_largest_block) {
    return pool_options::__impl_largest_block;
  } else if (__lpb < pool_options::__impl_smallest_block) {
    return pool_options::__impl_smallest_block;
  } else {
    return __lpb;
  }
}

inline _LIBCPP_INLINE_VISIBILITY pool_options
    __adjust_pool_options(pool_options __opts) _NOEXCEPT {
  __opts.max_blocks_per_chunk =
      __adjust_max_blocks_per_chunk(__opts.max_blocks_per_chunk);

  __opts.largest_required_pool_block =
      __adjust_largest_required_pool_block(__opts.largest_required_pool_block);

  return __opts;
}


struct __single_linked_chunk_node {
  __single_linked_chunk_node *__next_;
  size_t __size_;
  alignas(std::max_align_t) char __memory_[0];

  static inline _LIBCPP_INLINE_VISIBILITY
  void __push(__single_linked_chunk_node **__head_ptr,
              __single_linked_chunk_node *__n) {
    __n->__next_ = *__head_ptr;
    *__head_ptr = __n;
  }

  static inline _LIBCPP_INLINE_VISIBILITY
  void __remove(__single_linked_chunk_node **__head_ptr,
                __single_linked_chunk_node *__n)
  {
    auto **__prev = __head_ptr;
    auto *__idx = *__head_ptr;
    while (__idx != __n) {
      __prev = &__idx->__next_;
      __idx = *__prev;
    }
    *__prev = __n->__next_;
    __n->__next_ = nullptr;
  }
};


struct __double_linked_chunk_node {
  __double_linked_chunk_node *__next_;
  __double_linked_chunk_node **__prev_next_addr_;
  size_t __size_;
  alignas(std::max_align_t) char __memory_[0];

  static inline _LIBCPP_INLINE_VISIBILITY
  void __push(__double_linked_chunk_node **__head_ptr,
                     __double_linked_chunk_node *__n) {
    __n->__next_ = *__head_ptr;
    __n->__prev_next_addr_ = __head_ptr;
    if (*__head_ptr)
      (*__head_ptr)->__prev_next_addr_ = &__n->__next_;
    *__head_ptr = __n;
  }

  static inline _LIBCPP_INLINE_VISIBILITY
  void __remove(__double_linked_chunk_node **,
                __double_linked_chunk_node *__n) {
    *(__n->__prev_next_addr_) = __n->__next_;
    if (__n->__next_)
      __n->__next_->__prev_next_addr_ = __n->__prev_next_addr_;
  }
};

template <class _ChunkNode>
class _LIBCPP_TYPE_VIS_ONLY __basic_chunk_allocator {
  static_assert(is_standard_layout<_ChunkNode>::value,
                "_ChunkNode must be standard layout");
  static_assert(is_trivially_destructible<_ChunkNode>::value,
                "_ChunkNode must be trivially destructible");

  static inline _LIBCPP_INLINE_VISIBILITY
  _ChunkNode *__memory_to_chunk(void *__p) _NOEXCEPT {
    return static_cast<_ChunkNode *>(static_cast<void *>(
        static_cast<char *>(__p) - offsetof(_ChunkNode, __memory_)));
  }
public:
  _LIBCPP_INLINE_VISIBILITY
  __basic_chunk_allocator() : __head_(nullptr) {}
  __basic_chunk_allocator(__basic_chunk_allocator const &) = delete;
  __basic_chunk_allocator &operator=(__basic_chunk_allocator const &) = delete;

  _LIBCPP_INLINE_VISIBILITY
  void *__allocate(memory_resource *__res, size_t __s) {
    if (__s == 0)
      __s = 1;
    const size_t __alloc_size =
        __aligned_allocation_size(sizeof(_ChunkNode) + __s);
    return __insert_new_chunk(__res->allocate(__alloc_size, __max_align()),
                              __alloc_size);
  }

  _LIBCPP_INLINE_VISIBILITY
  void __deallocate(memory_resource *__res, void *__p) _NOEXCEPT {
    if (!__p)
      return;
    _ChunkNode *const __n = __memory_to_chunk(__p);
    _ChunkNode::__remove(&__head_, __n);
    __res->deallocate(__n, __n->__size_, __max_align());
  }

  _LIBCPP_INLINE_VISIBILITY
  void __release(memory_resource *__res) _NOEXCEPT {
    while (__head_) {
      auto *__p = __head_;
      __head_ = __head_->__next_;
      __res->deallocate(__p, __p->__size_, __max_align());
    }
  }

private:
  _LIBCPP_INLINE_VISIBILITY
  void *__insert_new_chunk(void *__p, size_t __s) _NOEXCEPT {
    _ChunkNode *__n = ::new (__p) _ChunkNode;
    __n->__size_ = __s;
    _ChunkNode::__push(&__head_, __n);
    return static_cast<void *>(&__n->__memory_);
  }

private:
  _ChunkNode *__head_;
};

typedef __basic_chunk_allocator<__double_linked_chunk_node> __chunk_allocator;
typedef __basic_chunk_allocator<__single_linked_chunk_node>
    __single_linked_chunk_allocator;


class _LIBCPP_TYPE_VIS_ONLY monotonic_buffer_resource : public memory_resource {
  static constexpr size_t __min_buf_size = 512;

public:
  explicit monotonic_buffer_resource(memory_resource *__res)
      : __buf_(nullptr), __left_(0), __next_buf_size_(__min_buf_size),
        __res_(__res) { }

  monotonic_buffer_resource(size_t __init_size, memory_resource *__res)
      : __buf_(nullptr), __left_(0),
        __next_buf_size_(__init_size), __res_(__res) {}

  monotonic_buffer_resource(void *__buf, size_t __buf_size,
                            memory_resource *__res)
      : __buf_(__buf), __left_(__buf_size), __next_buf_size_(__min_buf_size),
        __res_(__res) {}

  monotonic_buffer_resource()
      : monotonic_buffer_resource(get_default_resource()) {}

  explicit monotonic_buffer_resource(size_t __init_size)
      : monotonic_buffer_resource(__init_size, get_default_resource()) {}

  monotonic_buffer_resource(void *__buf, size_t __buf_size)
      : monotonic_buffer_resource(__buf, __buf_size, get_default_resource()) {}

  monotonic_buffer_resource(monotonic_buffer_resource const &) = delete;

  _LIBCPP_FUNC_VIS
  virtual ~monotonic_buffer_resource(); // KEY FUNCTION

  monotonic_buffer_resource &
      operator=(monotonic_buffer_resource const &) = delete;

  _LIBCPP_INLINE_VISIBILITY
  void release() {
    __alloc_.__release(__res_);
    __buf_ = nullptr;
    __left_ = 0;
  }

  _LIBCPP_INLINE_VISIBILITY
  memory_resource *upstream_resource() const _NOEXCEPT { return __res_; }

protected:
  virtual void *do_allocate(size_t __bytes, size_t __align) {
    if (void *__p = __take_from_buf(__bytes, __align))
      return __p;
    return __alloc_from_upstream(__bytes, __align);
  }

  virtual void do_deallocate(void *, size_t, size_t) { }

  virtual bool do_is_equal(memory_resource const &__other) const _NOEXCEPT {
    return this ==
        dynamic_cast<monotonic_buffer_resource const *>(&__other);
  }

private:
  _LIBCPP_INLINE_VISIBILITY
  void *__take_from_buf(size_t __s, size_t __a) _NOEXCEPT {
    void* __p = nullptr;
    if (__buf_ && (__p = _VSTD::align(__a, __s, __buf_, __left_))) {
        __buf_ = static_cast<void*>(static_cast<char*>(__p) + __s);
        __left_ -= __s;
    }
    return __p;
  }

  _LIBCPP_INLINE_VISIBILITY
  void *__alloc_from_upstream(size_t __s, size_t __a) {
    size_t __alloc_size = std::max<size_t>(
        __aligned_allocation_size(__s, __a),
        __next_buf_size_);
    __increment_buf_size(__alloc_size);
    __buf_ = __alloc_.__allocate(__res_, __alloc_size);
    __left_ = __alloc_size;
    return __take_from_buf(__s, __a);
  }

  _LIBCPP_INLINE_VISIBILITY
  void __increment_buf_size(size_t __s) _NOEXCEPT {
    size_t const __possible_next =
        _VSTD::max(__round_up_pow_2(__s), __next_buf_size_ << 1);
    __next_buf_size_ = _VSTD::max(__possible_next, __next_buf_size_);
  }

private:
  void *__buf_;
  size_t __left_;
  size_t __next_buf_size_;
  memory_resource *__res_;
  __single_linked_chunk_allocator __alloc_;
};

_LIBCPP_END_NAMESPACE_LFTS_PMR

#endif /* _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE */
