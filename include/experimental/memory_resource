// -*- C++ -*-
//===------------------------ memory_resource -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE
#define _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE

/**
    experimental/memory_resource synopsis

// C++1y

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
namespace pmr {

  class memory_resource;

  bool operator==(const memory_resource& a,
                  const memory_resource& b) noexcept;
  bool operator!=(const memory_resource& a,
                  const memory_resource& b) noexcept;

  template <class Tp> class polymorphic_allocator;

  template <class T1, class T2>
  bool operator==(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;
  template <class T1, class T2>
  bool operator!=(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;

  // The name resource_adaptor_imp is for exposition only.
  template <class Allocator> class resource_adaptor_imp;

  template <class Allocator>
    using resource_adaptor = resource_adaptor_imp<
      allocator_traits<Allocator>::rebind_alloc<char>>;

  // Global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;

  // The default memory resource
  memory_resource* set_default_resource(memory_resource* r) noexcept;
  memory_resource* get_default_resource() noexcept;

  // Standard memory resources
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;

} // namespace pmr
} // namespace fundamentals_v1
} // namespace experimental
} // namespace std


 */

#include <experimental/__config>

#if _LIBCPP_STD_VER > 11

#include <memory>

_LIBCPP_BEGIN_NAMESPACE_LFTS
namespace pmr
{
    class _LIBCPP_TYPE_VIS_ONLY memory_resource;

    bool operator==(memory_resource const &, memory_resource const &) _NOEXCEPT;
    bool operator!=(memory_resource const &, memory_resource const &) _NOEXCEPT;

    template <class _Tp> class _LIBCPP_TYPE_VIS_ONLY polymorphic_allocator;

    template <class _Tp, class _Up>
    bool operator==(polymorphic_allocator<_Tp> const &, polymorphic_allocator<_Up> const &) _NOEXCEPT;

    template <class _Tp, class _Up>
    bool operator!=(polymorphic_allocator<_Tp> const &, polymorphic_allocator<_Up> const &) _NOEXCEPT;

    template <class _Alloc> class __resource_adapter_imp;

    template <class _Alloc>
    using resource_adapter 
        = __resource_adapter_imp<allocator_traits<_Alloc>::rebind_alloc<char>>;

    memory_resource * new_delete_resource() _NOEXCEPT;
    memory_resource * null_memory_resource() _NOEXCEPT;

    struct _LIBCPP_TYPE_VIS_ONLY pool_options;
    class _LIBCPP_TYPE_VIS_ONLY synchronized_pool_resource;
    class _LIBCPP_TYPE_VIS_ONLY unsynchronized_pool_resource;
    class _LIBCPP_TYPE_VIS_ONLY monotonic_buffer_resource;
}                                                           // namespace pmr
_LIBCPP_END_NAMESPACE_LFTS

#endif /* _LIBCPP_STD_VER > 11 */

#endif /* _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE */
