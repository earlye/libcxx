// -*- C++ -*-
//===--------------------------- filesystem -------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
#ifndef _LIBCPP_EXPERIMENTAL_FILESYSTEM
#define _LIBCPP_EXPERIMENTAL_FILESYSTEM
/*
    filesystem synopsis

    namespace std { namespace experimental { namespace filesystem { inline namespace v1 {

    class path;

    void swap(path& lhs, path& rhs) _NOEXCEPT;
    size_t hash_value(const path& p) _NOEXCEPT;

    bool operator==(const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator!=(const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator< (const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator<=(const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator> (const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator>=(const path& lhs, const path& rhs) _NOEXCEPT;

    path operator/ (const path& lhs, const path& rhs);

    template <class charT, class traits>
    basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const path& p);

    template <class charT, class traits>
    basic_istream<charT, traits>&
    operator>>(basic_istream<charT, traits>& is, path& p);

    template <class Source>
      path u8path(const Source& source);
    template <class InputIterator>
      path u8path(InputIterator first, InputIterator last);

    class filesystem_error;
    class directory_entry;

    class directory_iterator;

    // enable directory_iterator range-based for statements
    directory_iterator begin(directory_iterator iter) noexcept;
    directory_iterator end(const directory_iterator&) noexcept;

    class recursive_directory_iterator;

    // enable recursive_directory_iterator range-based for statements
    recursive_directory_iterator begin(recursive_directory_iterator iter) noexcept;
    recursive_directory_iterator end(const recursive_directory_iterator&) noexcept;

    class file_status;

    struct space_info
    {
      uintmax_t capacity;
      uintmax_t free; 
      uintmax_t available;
    };

    enum class file_type;
    enum class perms;
    enum class copy_options;
    enum class directory_options;

    typedef chrono::time_point<trivial-clock>  file_time_type;

    // operational functions

    path absolute(const path& p, const path& base=current_path());

    path canonical(const path& p, const path& base = current_path());
    path canonical(const path& p, error_code& ec);
    path canonical(const path& p, const path& base, error_code& ec);

    void copy(const path& from, const path& to);
    void copy(const path& from, const path& to, error_code& ec) _NOEXCEPT;
    void copy(const path& from, const path& to, copy_options options);
    void copy(const path& from, const path& to, copy_options options,  
                   error_code& ec) _NOEXCEPT;

    bool copy_file(const path& from, const path& to);
    bool copy_file(const path& from, const path& to, error_code& ec) _NOEXCEPT;
    bool copy_file(const path& from, const path& to, copy_options option);
    bool copy_file(const path& from, const path& to, copy_options option,
                           error_code& ec) _NOEXCEPT;

    void copy_symlink(const path& existing_symlink, const path& new_symlink);
    void copy_symlink(const path& existing_symlink, const path& new_symlink,
                              error_code& ec) _NOEXCEPT;

    bool create_directories(const path& p);
    bool create_directories(const path& p, error_code& ec) _NOEXCEPT;

    bool create_directory(const path& p);
    bool create_directory(const path& p, error_code& ec) _NOEXCEPT;

    bool create_directory(const path& p, const path& attributes);
    bool create_directory(const path& p, const path& attributes,
                                  error_code& ec) _NOEXCEPT;

    void create_directory_symlink(const path& to, const path& new_symlink);
    void create_directory_symlink(const path& to, const path& new_symlink,
                                          error_code& ec) _NOEXCEPT;

    void create_hard_link(const path& to, const path& new_hard_link);
    void create_hard_link(const path& to, const path& new_hard_link,
                                  error_code& ec) _NOEXCEPT;

    void create_symlink(const path& to, const path& new_symlink);
    void create_symlink(const path& to, const path& new_symlink,
                                error_code& ec) _NOEXCEPT;

    path current_path();
    path current_path(error_code& ec);
    void current_path(const path& p);
    void current_path(const path& p, error_code& ec) _NOEXCEPT;

    bool exists(file_status s) _NOEXCEPT;
    bool exists(const path& p);
    bool exists(const path& p, error_code& ec) _NOEXCEPT;

    bool equivalent(const path& p1, const path& p2);
    bool equivalent(const path& p1, const path& p2, error_code& ec) _NOEXCEPT;

    uintmax_t    file_size(const path& p);
    uintmax_t    file_size(const path& p, error_code& ec) _NOEXCEPT;

    uintmax_t    hard_link_count(const path& p);
    uintmax_t    hard_link_count(const path& p, error_code& ec) _NOEXCEPT;

    bool is_block_file(file_status s) _NOEXCEPT;
    bool is_block_file(const path& p);
    bool is_block_file(const path& p, error_code& ec) _NOEXCEPT;

    bool is_character_file(file_status s) _NOEXCEPT;
    bool is_character_file(const path& p);
    bool is_character_file(const path& p, error_code& ec) _NOEXCEPT;

    bool is_directory(file_status s) _NOEXCEPT;
    bool is_directory(const path& p);
    bool is_directory(const path& p, error_code& ec) _NOEXCEPT;

    bool is_empty(const path& p);
    bool is_empty(const path& p, error_code& ec) _NOEXCEPT;

    bool is_fifo(file_status s) _NOEXCEPT;
    bool is_fifo(const path& p);
    bool is_fifo(const path& p, error_code& ec) _NOEXCEPT;

    bool is_other(file_status s) _NOEXCEPT;
    bool is_other(const path& p);
    bool is_other(const path& p, error_code& ec) _NOEXCEPT;

    bool is_regular_file(file_status s) _NOEXCEPT; 
    bool is_regular_file(const path& p);
    bool is_regular_file(const path& p, error_code& ec) _NOEXCEPT;

    bool is_socket(file_status s) _NOEXCEPT;
    bool is_socket(const path& p);
    bool is_socket(const path& p, error_code& ec) _NOEXCEPT;

    bool is_symlink(file_status s) _NOEXCEPT;
    bool is_symlink(const path& p);
    bool is_symlink(const path& p, error_code& ec) _NOEXCEPT;

    file_time_type  last_write_time(const path& p);
    file_time_type  last_write_time(const path& p, error_code& ec) _NOEXCEPT;
    void last_write_time(const path& p, file_time_type new_time);
    void last_write_time(const path& p, file_time_type new_time,
                                 error_code& ec) _NOEXCEPT;

    void permissions(const path& p, perms prms);
    void permissions(const path& p, perms prms, error_code& ec) _NOEXCEPT;

    path read_symlink(const path& p);
    path read_symlink(const path& p, error_code& ec);

    bool remove(const path& p);
    bool remove(const path& p, error_code& ec) _NOEXCEPT;

    uintmax_t    remove_all(const path& p);
    uintmax_t    remove_all(const path& p, error_code& ec) _NOEXCEPT;

    void rename(const path& from, const path& to);
    void rename(const path& from, const path& to, error_code& ec) _NOEXCEPT;

    void resize_file(const path& p, uintmax_t size);
    void resize_file(const path& p, uintmax_t size, error_code& ec) _NOEXCEPT;

    space_info   space(const path& p);
    space_info   space(const path& p, error_code& ec) _NOEXCEPT;

    file_status  status(const path& p);
    file_status  status(const path& p, error_code& ec) _NOEXCEPT;

    bool status_known(file_status s) _NOEXCEPT;

    file_status  symlink_status(const path& p);
    file_status  symlink_status(const path& p, error_code& ec) _NOEXCEPT;

    path system_complete(const path& p);
    path system_complete(const path& p, error_code& ec);

    path temp_directory_path();
    path temp_directory_path(error_code& ec);

} } } }  // namespaces std::experimental::filesystem::v1

*/

#include <experimental/__config>
#include <cstddef>
#include <chrono>
#include <iterator>
#include <iosfwd>
#include <locale>
#include <memory>
#include <stack>
#include <string>
#include <system_error>
#include <utility>

#include <__debug>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_FILESYSTEM

typedef chrono::time_point<std::chrono::system_clock>  file_time_type;

struct _LIBCPP_TYPE_VIS space_info
{
  uintmax_t capacity;
  uintmax_t free;
  uintmax_t available;
};

enum class _LIBCPP_TYPE_VIS file_type : signed char
{
    none       = 0,
    not_found  = -1,
    regular    = 1,
    directory  = 2,
    symlink    = 3,
    block      = 4,
    character  = 5,
    fifo       = 6,
    socket     = 7,
    unknown    = 8
};

enum class _LIBCPP_TYPE_VIS perms : unsigned
{
    none         = 0,

    owner_read   = 0400,
    owner_write  = 0200,
    owner_exec   = 0100,
    owner_all    = 0700,

    group_read   = 040,
    group_write  = 020,
    group_exec   = 010,
    group_all    = 070,

    others_read  = 04,
    others_write = 02,
    others_exec  = 01,
    others_all   = 07,

    all          = 0777,

    set_uid      = 04000,
    set_gid      = 02000,
    sticky_bit   = 01000,
    mask         = 07777,
    unknown      = 0xFFFF,

    add_perms        = 0x10000,
    remove_perms     = 0x20000,
    resolve_symlinks = 0x40000
};

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR perms operator&(perms _LHS, perms _RHS)
{ return static_cast<perms>(static_cast<unsigned>(_LHS) & static_cast<unsigned>(_RHS)); }

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR perms operator|(perms _LHS, perms _RHS)
{ return static_cast<perms>(static_cast<unsigned>(_LHS) | static_cast<unsigned>(_RHS)); }

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR perms operator^(perms _LHS, perms _RHS)
{ return static_cast<perms>(static_cast<unsigned>(_LHS) ^ static_cast<unsigned>(_RHS)); }

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR perms operator~(perms _LHS)
{ return static_cast<perms>(~static_cast<unsigned>(_LHS)); }

_LIBCPP_INLINE_VISIBILITY
inline perms& operator&=(perms& _LHS, perms _RHS)
{ return _LHS = _LHS & _RHS; }

_LIBCPP_INLINE_VISIBILITY
inline perms& operator|=(perms& _LHS, perms _RHS)
{ return _LHS = _LHS | _RHS; }

_LIBCPP_INLINE_VISIBILITY
inline perms& operator^=(perms& _LHS, perms _RHS)
{ return _LHS = _LHS ^ _RHS; }

enum class _LIBCPP_TYPE_VIS copy_options : unsigned short
{
    none               = 0,
    skip_existing      = 1,
    overwrite_existing = 2,
    update_existing    = 4,
    recursive          = 8,
    copy_symlinks      = 16,
    skip_symlinks      = 32,
    directories_only   = 64,
    create_symlinks    = 128,
    create_hard_links  = 256
};

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR copy_options operator&(copy_options _LHS, copy_options _RHS)
{ return static_cast<copy_options>(static_cast<unsigned short>(_LHS) & static_cast<unsigned short>(_RHS)); }

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR copy_options operator|(copy_options _LHS, copy_options _RHS)
{ return static_cast<copy_options>(static_cast<unsigned short>(_LHS) | static_cast<unsigned short>(_RHS)); }

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR copy_options operator^(copy_options _LHS, copy_options _RHS)
{ return static_cast<copy_options>(static_cast<unsigned short>(_LHS) ^ static_cast<unsigned short>(_RHS)); }

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR copy_options operator~(copy_options _LHS)
{ return static_cast<copy_options>(~static_cast<unsigned short>(_LHS)); }

_LIBCPP_INLINE_VISIBILITY
inline copy_options& operator&=(copy_options& _LHS, copy_options _RHS)
{ return _LHS = _LHS & _RHS; }

_LIBCPP_INLINE_VISIBILITY
inline copy_options& operator|=(copy_options& _LHS, copy_options _RHS)
{ return _LHS = _LHS | _RHS; }

_LIBCPP_INLINE_VISIBILITY
inline copy_options& operator^=(copy_options& _LHS, copy_options _RHS)
{ return _LHS = _LHS ^ _RHS; }


enum class directory_options : unsigned char
{
    none                     = 0,
    follow_directory_symlink = 1,
    skip_permission_denied   = 2
};

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR directory_options operator&(directory_options _LHS, directory_options _RHS)
{ return static_cast<directory_options>(static_cast<unsigned char>(_LHS) & static_cast<unsigned char>(_RHS)); }

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR directory_options operator|(directory_options _LHS, directory_options _RHS)
{ return static_cast<directory_options>(static_cast<unsigned char>(_LHS) | static_cast<unsigned char>(_RHS)); }

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR directory_options operator^(directory_options _LHS, directory_options _RHS)
{ return static_cast<directory_options>(static_cast<unsigned char>(_LHS) ^ static_cast<unsigned char>(_RHS)); }

_LIBCPP_INLINE_VISIBILITY
inline _LIBCPP_CONSTEXPR directory_options operator~(directory_options _LHS)
{ return static_cast<directory_options>(~static_cast<unsigned char>(_LHS)); }

_LIBCPP_INLINE_VISIBILITY
inline directory_options& operator&=(directory_options& _LHS, directory_options _RHS)
{ return _LHS = _LHS & _RHS; }

_LIBCPP_INLINE_VISIBILITY
inline directory_options& operator|=(directory_options& _LHS, directory_options _RHS)
{ return _LHS = _LHS | _RHS; }

_LIBCPP_INLINE_VISIBILITY
inline directory_options& operator^=(directory_options& _LHS, directory_options _RHS)
{ return _LHS = _LHS ^ _RHS; }


class _LIBCPP_TYPE_VIS file_status
{
public:
    // constructors
    _LIBCPP_INLINE_VISIBILITY
    explicit file_status(file_type __ft = file_type::none,
                         perms __prms   = perms::unknown) _NOEXCEPT
      : __ft_(__ft), __prms_(__prms)
    {}

    file_status(const file_status&) _NOEXCEPT = default;
    file_status(file_status&&) _NOEXCEPT = default;

    _LIBCPP_INLINE_VISIBILITY
    ~file_status() {}

    file_status& operator=(const file_status&) _NOEXCEPT = default;
    file_status& operator=(file_status&&) _NOEXCEPT = default;

    // observers
    _LIBCPP_ALWAYS_INLINE
    file_type type() const _NOEXCEPT {
        return __ft_;
    }

    _LIBCPP_ALWAYS_INLINE
    perms permissions() const _NOEXCEPT {
        return __prms_;
    }

    // modifiers
    _LIBCPP_ALWAYS_INLINE
    void type(file_type __ft) _NOEXCEPT {
        __ft_ = __ft;
    }

    _LIBCPP_ALWAYS_INLINE
    void permissions(perms __p) _NOEXCEPT {
        __prms_ = __p;
    }
private:
    file_type __ft_;
    perms __prms_;
};

class _LIBCPP_TYPE_VIS directory_entry;

template <class _Tp> struct __can_convert_char {
  static const bool value = false;
};
template <> struct __can_convert_char<char> {
    static const bool value = true;
    using __char_type = char;
    static _LIBCPP_CONSTEXPR char preferred_separator = '/';
    static _LIBCPP_CONSTEXPR char __other_separator = '\\';
};
template <> struct __can_convert_char<wchar_t>  {
    static const bool value = true;
    using __char_type = wchar_t;
    static _LIBCPP_CONSTEXPR wchar_t preferred_separator = L'/';
    static _LIBCPP_CONSTEXPR wchar_t __other_separator = L'\\';
};
template <> struct __can_convert_char<char16_t> {
    static const bool value = true;
    using __char_type = char16_t;
    static _LIBCPP_CONSTEXPR char16_t preferred_separator = u'/';
    static _LIBCPP_CONSTEXPR char16_t __other_separator = u'\\';
};
template <> struct __can_convert_char<char32_t> {
    static const bool value = true;
    using __char_type = char32_t;
    static _LIBCPP_CONSTEXPR char32_t preferred_separator = U'/';
    static _LIBCPP_CONSTEXPR char32_t __other_separator = U'\\';
};

template <class _ECharT>
typename enable_if<__can_convert_char<_ECharT>::value, bool>::type
__is_separator(_ECharT __e) {
    using _Traits = __can_convert_char<_ECharT>;
    return __e == _Traits::preferred_separator;
};

struct _NullSentinal {};


template <class _Tp>
using _Void = void;

template <class _Tp, class = void>
struct __is_pathable_string : public false_type {};

template <class _ECharT, class _Traits, class _Alloc>
struct __is_pathable_string<basic_string<_ECharT, _Traits, _Alloc>,
                            _Void<typename __can_convert_char<_ECharT>::__char_type>>
: public __can_convert_char<_ECharT>
{
    using _Str = basic_string<_ECharT, _Traits, _Alloc>;
    using _Base = __can_convert_char<_ECharT>;
    static _ECharT const* __range_begin(_Str const& __s) { return __s.data(); }
    static _ECharT const* __range_end(_Str const& __s) { return __s.data() + __s.length(); }
    static _ECharT __first_or_null(_Str const& __s) {
        return __s.empty() ? _ECharT{} : __s[0];
    }
};

template <class _Tp>
using _UnqualPtrType = typename remove_const<typename remove_pointer<_Tp>::type>::type;

template <class _Source,
          class _DS = typename decay<_Source>::type,
          bool _IsCharPtr = is_pointer<_DS>::value &&
                            __can_convert_char<_UnqualPtrType<_DS>>::value
        >
struct __is_pathable_char_array : false_type {};

template <class _Source, class _ECharT>
struct __is_pathable_char_array<_Source, _ECharT*, true>
        : __can_convert_char<typename remove_const<_ECharT>::type>
{
  using _Base = __can_convert_char<typename std::remove_const<_ECharT>::type>;

  static _ECharT const* __range_begin(const _ECharT* __b) { return __b; }
  static _ECharT const* __range_end(const _ECharT* __b)
  {
      using _Iter = const _ECharT*;
      const _ECharT __sentinal = _ECharT{};
      _Iter __e = __b;
      for (; *__e != __sentinal; ++__e)
          ;
      return __e;
  }

  static _ECharT __first_or_null(const _ECharT* __b) { return *__b; }
};

template <class _Iter, bool _IsIt = __is_input_iterator<_Iter>::value, class = void>
struct __is_pathable_iter : false_type {};

template <class _Iter>
struct __is_pathable_iter<_Iter, true,
        _Void<typename __can_convert_char<typename iterator_traits<_Iter>::value_type>::__char_type>>
        : __can_convert_char<typename iterator_traits<_Iter>::value_type>
{
  using _ECharT = typename iterator_traits<_Iter>::value_type;
  using _Base = __can_convert_char<_ECharT>;

  static _Iter         __range_begin(_Iter __b) { return __b; }
  static _NullSentinal __range_end(_Iter)       { return _NullSentinal{}; }

  static _ECharT __first_or_null(_Iter __b) { return *__b; }

};

template <class _Tp, bool _IsStringT =  __is_pathable_string<_Tp>::value,
                     bool _IsCharIterT = __is_pathable_char_array<_Tp>::value,
                     bool _IsIterT = !_IsCharIterT && __is_pathable_iter<_Tp>::value
         >
struct __is_pathable : false_type {
  static_assert(!_IsStringT && !_IsCharIterT && !_IsIterT, "Must all be false");
};

template <class _Tp>
struct __is_pathable<_Tp, true, false, false> : __is_pathable_string<_Tp> {};


template <class _Tp>
struct __is_pathable<_Tp, false, true, false> : __is_pathable_char_array<_Tp> {};


template <class _Tp>
struct __is_pathable<_Tp, false, false, true> : __is_pathable_iter<_Tp> {};


template <class _ECharT>
using _WidenFromNative = __widen_from_utf8<sizeof(_ECharT)*__CHAR_BIT__>;

template <class _ECharT>
struct _PathCVT {
    static_assert(__can_convert_char<_ECharT>::value, "Char type not convertible");

    typedef __narrow_to_utf8<sizeof(_ECharT)*__CHAR_BIT__> _Narrower;

    static void __append_range(string& __dest, _ECharT const* __b, _ECharT const* __e)  {
        _Narrower()(back_inserter(__dest), __b, __e);
    }

    template <class _Iter>
    static void __append_range(string& __dest, _Iter __b, _Iter __e) {
        static_assert(!is_same<_Iter, _ECharT*>::value, "Call const overload");
        if (__b == __e) return;
        basic_string<_ECharT> __tmp(__b, __e);
        _Narrower()(back_inserter(__dest), __tmp.data(),
                    __tmp.data() + __tmp.length());
    }

    template <class _Iter>
    static void __append_range(string& __dest, _Iter __b, _NullSentinal) {
        static_assert(!is_same<_Iter, _ECharT*>::value, "Call const overload");
        const _ECharT __sentinal = _ECharT{};
        if (*__b == __sentinal) return;
        basic_string<_ECharT> __tmp;
        for (; *__b != __sentinal; ++__b)
            __tmp.push_back(*__b);
        _Narrower()(back_inserter(__dest), __tmp.data(),
                    __tmp.data() + __tmp.length());
    }

    template <class _Source>
    static void __append_source(string& __dest, _Source const& __s)
    {
        using _Traits = __is_pathable<_Source>;
        __append_range(__dest, _Traits::__range_begin(__s), _Traits::__range_end(__s));
    }
};


template <>
struct _PathCVT<char> {
    template <class _Iter>
    static void __append_range(string& __dest, _Iter __b, _Iter __e) {
        // TODO(EricWF) We get better allocation behavior here if we don't
        // provide the same exception safety guarantees as string.append.
        // __dest.append(__b, __e);
        for (; __b != __e; ++__b)
            __dest.push_back(*__b);
    }

    template <class _Iter>
    static void __append_range(string& __dest, _Iter __b, _NullSentinal) {
        const char __sentinal = char{};
        for (; *__b != __sentinal; ++__b)
            __dest.push_back(*__b);
    }

    template <class _Source>
    static void __append_source(string& __dest, _Source const& __s)
    {
        using _Traits = __is_pathable<_Source>;
        __append_range(__dest, _Traits::__range_begin(__s), _Traits::__range_end(__s));
    }
};


template <class _Tp>
using _SourceChar = typename __is_pathable<_Tp>::__char_type;

template <class _Tp>
using _SourceCVT = _PathCVT<_SourceChar<_Tp>>;

class _LIBCPP_TYPE_VIS path
{
public:
    typedef char value_type;
    typedef basic_string<value_type> string_type;
    static _LIBCPP_CONSTEXPR value_type preferred_separator = '/';
    static _LIBCPP_CONSTEXPR value_type __other_separator = '\\';

    // constructors and destructor
    _LIBCPP_INLINE_VISIBILITY
    path() _NOEXCEPT {}

    _LIBCPP_INLINE_VISIBILITY
    path(const path& __p) : __pn_(__p.__pn_) {}

    _LIBCPP_INLINE_VISIBILITY
    path(path&& __p) _NOEXCEPT : __pn_(_VSTD::move(__p.__pn_)) {}

    template <
        class _Source,
        class = typename enable_if<
                    __is_pathable<_Source>::value
                >::type
        >
    path(const _Source& __src) {
        _SourceCVT<_Source>::__append_source(__pn_, __src);
    }

    template <class _InputIt>
    path(_InputIt __first, _InputIt __last)
    {
        typedef typename iterator_traits<_InputIt>::value_type _ItVal;
        _PathCVT<_ItVal>::__append_range(__pn_, __first, __last);
    }

    // TODO
    template <class _Source>
        path(const _Source& __src, const locale& __loc);
    template <class _InputIt>
        path(_InputIt __first, _InputIt _last, const locale& __loc);

    _LIBCPP_INLINE_VISIBILITY
    ~path() {}

    // assignments
    _LIBCPP_INLINE_VISIBILITY
    path& operator=(const path& __p) {
        __pn_ = __p.__pn_;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator=(path&& __p) _NOEXCEPT {
        __pn_ = _VSTD::move(__p.__pn_);
        return *this;
    }

    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    operator=(const _Source& __src)
    {
        return this->assign(__src);
    }


    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    assign(const _Source& __src)
    {
        using _CVT = _PathCVT<_SourceChar<_Source>>;
        __pn_.clear();
        _CVT::__append_source(__pn_, __src);
        return *this;
    }

    template <class _InputIt>
    path& assign(_InputIt __first, _InputIt __last)
    {
        typedef typename iterator_traits<_InputIt>::value_type _ItVal;
        __pn_.clear();
        _PathCVT<_ItVal>::__append_range(__pn_, __first, __last);
        return *this;
    }

    template <class _ECharT>
    void __append_sep_if_needed(_ECharT __first_or_null) {
        const _ECharT __null_val = {};
        bool __append_sep = !empty()                       &&
                            !__is_separator(__pn_.back())  &&
                            __first_or_null != __null_val  && // non-empty
                            !__is_separator(__first_or_null);
        if (__append_sep)
            __pn_ += preferred_separator;
    }


    // appends
    path& operator/=(const path& __p)
    {
        __append_sep_if_needed(__p.empty() ? char{} : __p.__pn_[0]);
        __pn_ += __p.native();
        return *this;
    }

    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    operator/=(const _Source& __src)
    {
        using _Traits = __is_pathable<_Source>;
        using _CVT = _PathCVT<_SourceChar<_Source>>;
        __append_sep_if_needed(_Traits::__first_or_null(__src));
        _CVT::__append_source(__pn_, __src);
        return *this;
    }

    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    append(const _Source& __src)
    {
        return this->operator/=(__src);
    }

    template <class _InputIt>
    path& append(_InputIt __first, _InputIt __last)
    {
        typedef typename iterator_traits<_InputIt>::value_type _ItVal;
        static_assert(__can_convert_char<_ItVal>::value, "Must convertible");
        using _CVT = _PathCVT<_ItVal>;
        if (__first != __last) {
            __append_sep_if_needed(*__first);
            _CVT::__append_range(__pn_, __first, __last);
        }
        return *this;
    }

    // concatenation
    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(const path& __x) {
        __pn_ += __x.__pn_;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(const string_type& __x) {
        __pn_ += __x;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(const value_type* __x) {
        __pn_ += __x;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(value_type __x) {
        __pn_ += __x;
        return *this;
    }

    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    operator+=(const _Source& __x)
    {
        _SourceCVT<_Source>::__append_source(__pn_, __x);
        return *this;
    }

    template <class _ECharT>
    typename enable_if<__can_convert_char<_ECharT>::value, path&>::type
    operator+=(_ECharT __x)
    {
        basic_string<_ECharT> __tmp;
        __tmp += __x;
        _PathCVT<_ECharT>::__append_source(__pn_, __tmp);
        return *this;
    }

    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    concat(const _Source& __x)
    {
        return this->operator+=(__x);
    }

    template <class _InputIt>
    path& concat(_InputIt __first, _InputIt __last)
    {
        typedef typename iterator_traits<_InputIt>::value_type _ItVal;
        _PathCVT<_ItVal>::__append_range(__pn_, __first, __last);
        return *this;
    }

    // modifiers
    _LIBCPP_INLINE_VISIBILITY
    void  clear() _NOEXCEPT {
        __pn_.clear();
    }

    path& make_preferred() { return *this; }

    path& remove_filename() { return *this = parent_path(); }

    path& replace_filename(const path& __replacement) {
        remove_filename();
        return (*this /= __replacement);
    }

    path& replace_extension(const path& __replacement = path());

    _LIBCPP_INLINE_VISIBILITY
    void  swap(path& __rhs) _NOEXCEPT {
        __pn_.swap(__rhs.__pn_);
    }

    // native format observers
    _LIBCPP_INLINE_VISIBILITY
    const string_type& native() const _NOEXCEPT {
        return __pn_;
    }

    _LIBCPP_INLINE_VISIBILITY
    const value_type*  c_str() const _NOEXCEPT {
        return __pn_.c_str();
    }

    _LIBCPP_INLINE_VISIBILITY
    operator string_type() const { return __pn_;  }

    template <class _EcharT, class _Traits = char_traits<_EcharT>,
              class _Allocator = allocator<_EcharT> >
    basic_string<_EcharT, _Traits, _Allocator>
    string(const _Allocator& __a = _Allocator()) const {
        return generic_string<_EcharT, _Traits, _Allocator>(__a);
    };

    _LIBCPP_INLINE_VISIBILITY
    std::string string() const { return __pn_; }

    std::wstring wstring() const { return generic_wstring(); }
    std::string  u8string() const { return __pn_; }
    std::u16string u16string() const { return generic_u16string(); }
    std::u32string u32string() const { return generic_u32string(); }

    // generic format observers
    template <class _ECharT, class _Traits = char_traits<_ECharT>,
              class _Allocator = allocator<_ECharT> >
    basic_string<_ECharT, _Traits, _Allocator>
    generic_string(const _Allocator& __a = _Allocator()) const {
        using _CVT = __widen_from_utf8<sizeof(_ECharT)*__CHAR_BIT__>;
        using _Str = basic_string<_ECharT, _Traits, _Allocator>;
        _Str __s(__a);
        __s.reserve(__pn_.size());
        _CVT()(back_inserter(__s), __pn_.data(), __pn_.data() + __pn_.size());
        return __s;
    }

    std::string    generic_string() const    { return __pn_; }
    std::wstring   generic_wstring() const   { return generic_string<wchar_t>(); }
    std::string    generic_u8string() const  { return __pn_; }
    std::u16string generic_u16string() const { return generic_string<char16_t>(); }
    std::u32string generic_u32string() const { return generic_string<char32_t>(); }

    // compare
    _LIBCPP_INLINE_VISIBILITY
    int compare(const path& __p) const _NOEXCEPT {
        return __pn_.compare(__p.__pn_);
    }

    _LIBCPP_INLINE_VISIBILITY
    int compare(const string_type& __s) const {
        return __pn_.compare(__s);
    }

    _LIBCPP_INLINE_VISIBILITY
    int compare(const value_type* __s) const {
        return __pn_.compare(__s);
    }

    // decomposition
    path root_name() const;
    path root_directory() const;
    path root_path() const;
    path relative_path() const;
    path parent_path() const;
    path filename() const;
    path stem() const;
    path extension() const;

    // query
    _LIBCPP_INLINE_VISIBILITY
    bool empty() const _NOEXCEPT {
        return __pn_.empty();
    }

    bool has_root_name() const
    { return !root_name().empty(); }

    bool has_root_directory() const
    { return !root_directory().empty(); }

    bool has_root_path() const
    { return !root_path().empty(); }

    bool has_relative_path() const
    { return !relative_path().empty(); }

    bool has_parent_path() const
    { return !parent_path().empty(); }

    bool has_filename() const
    { return !filename().empty(); }

    bool has_stem() const
    { return !stem().empty(); }

    bool has_extension() const
    { return !extension().empty(); }

    bool is_absolute() const
    { return has_root_directory(); }

    bool is_relative() const
    { return !is_absolute(); }

    // iterators
    class iterator;
    typedef iterator const_iterator;

    iterator begin() const;
    iterator end() const;

private:
    string_type __pn_;
};


inline _LIBCPP_ALWAYS_INLINE
void swap(path& __lhs, path& __rhs) _NOEXCEPT
{
    __lhs.swap(__rhs);
}

inline _LIBCPP_INLINE_VISIBILITY
size_t hash_value(const path& __p) _NOEXCEPT
{
    hash<path::string_type> __h;
    return __h(__p.native());
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator==(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) == 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) != 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator<(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) < 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator<=(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) <= 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator>(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) > 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator>=(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) >= 0;
}

inline _LIBCPP_INLINE_VISIBILITY
path operator/(const path& __lhs, const path& __rhs)
{
    return path(__lhs) /= __rhs;
}

template <class _CharT, class _Traits>
_LIBCPP_INLINE_VISIBILITY
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p)
{
    __os << __p.native();
    return __os;
}

template <class _CharT, class _Traits>
_LIBCPP_INLINE_VISIBILITY
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, path& __p)
{
    path::string_type __tmp;
    __is >> __tmp;
    __p = __tmp;
    return __is;
}

template <class _Source>
path u8path(const _Source&); // TODO

template <class _InputIt>
path u8path(_InputIt, _InputIt); // TODO


class _LIBCPP_TYPE_VIS path::iterator
    : public _VSTD::iterator<bidirectional_iterator_tag, path>
{
public:
    _LIBCPP_INLINE_VISIBILITY
    iterator() : __elem_(), __path_ptr_(nullptr), __pos_(0) {}

    iterator(const iterator&) = default;
    iterator(iterator&&) = default;
    ~iterator() = default;

    iterator& operator=(const iterator&) = default;
    iterator& operator=(iterator&&) = default;

    _LIBCPP_INLINE_VISIBILITY
    const path& operator*() const {
        return __elem_;
    }

    _LIBCPP_INLINE_VISIBILITY
    const path& operator->() const {
        return __elem_;
    }

    _LIBCPP_INLINE_VISIBILITY
    iterator& operator++() {
        return __increment();
    }

    _LIBCPP_INLINE_VISIBILITY
    iterator operator++(int) {
        iterator __it(*this);
        this->operator++();
        return __it;
    }

    _LIBCPP_INLINE_VISIBILITY
    iterator& operator--() {
        return __decrement();
    }

    _LIBCPP_INLINE_VISIBILITY
    iterator operator--(int) {
        iterator __it(*this);
        this->operator--();
        return __it;
    }
private:
    _LIBCPP_FUNC_VIS
    iterator& __increment();

    _LIBCPP_FUNC_VIS
    iterator& __decrement();

    _LIBCPP_FUNC_VIS
    bool __set_position(size_t);

    _LIBCPP_FUNC_VIS
    bool __valid_iterator_position() const;
private:
    friend class path;
    friend bool operator==(const iterator&, const iterator&);

    path __elem_;
    const path* __path_ptr_;
    size_t __pos_;
};

inline _LIBCPP_INLINE_VISIBILITY
bool operator==(const path::iterator& __lhs, const path::iterator& __rhs)
{
    return __lhs.__path_ptr_ == __rhs.__path_ptr_ &&
           __lhs.__pos_ == __rhs.__pos_;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(const path::iterator& __lhs, const path::iterator& __rhs)
{
    return !(__lhs == __rhs);
}


class _LIBCPP_EXCEPTION_ABI filesystem_error : public system_error
{
public:
    _LIBCPP_INLINE_VISIBILITY
    filesystem_error(const string& __what, error_code __ec)
        : system_error(__ec, __what),
          __paths_(make_shared<_Storage>(path(), path()))
    {}

    _LIBCPP_INLINE_VISIBILITY
    filesystem_error(const string& __what, const path& __p1, error_code __ec)
        : system_error(__ec, __what),
        __paths_(make_shared<_Storage>(__p1, path()))
    {}

    _LIBCPP_INLINE_VISIBILITY
    filesystem_error(const string& __what, const path& __p1, const path& __p2,
                     error_code __ec)
        : system_error(__ec, __what),
          __paths_(make_shared<_Storage>(__p1, __p2))
    {}

    _LIBCPP_INLINE_VISIBILITY
    const path& path1() const _NOEXCEPT {
        return __paths_->first;
    }

    _LIBCPP_INLINE_VISIBILITY
    const path& path2() const _NOEXCEPT {
        return __paths_->second;
    }

    // TODO(ericwf): Create a custom error message.
    //const char* what() const _NOEXCEPT;

private:
    typedef pair<path, path> _Storage;
    shared_ptr<_Storage> __paths_;
};


// operational functions

path absolute(const path&);
path absolute(const path&, const path&);

path canonical(const path&);
path canonical(const path&, const path&);
path canonical(const path&, error_code&);
path canonical(const path&, const path&, error_code&);

void copy(const path&, const path&);
void copy(const path&, const path&, error_code&) _NOEXCEPT;
void copy(const path&, const path&, copy_options);
void copy(const path&, const path&, copy_options, error_code&) _NOEXCEPT;

bool copy_file(const path&, const path&);
bool copy_file(const path&, const path&, error_code&) _NOEXCEPT;
bool copy_file(const path&, const path&, copy_options);
bool copy_file(const path&, const path&, copy_options, error_code&) _NOEXCEPT;

void copy_symlink(const path&, const path&);
void copy_symlink(const path&, const path&, error_code&) _NOEXCEPT;

bool create_directories(const path&);
bool create_directories(const path&, error_code&) _NOEXCEPT;

bool create_directory(const path&);
bool create_directory(const path&, error_code&) _NOEXCEPT;

bool create_directory(const path&, const path&);
bool create_directory(const path&, const path&, error_code&) _NOEXCEPT;

void create_directory_symlink(const path&, const path&);
void create_directory_symlink(const path&, const path&, error_code&) _NOEXCEPT;

void create_hard_link(const path&, const path&);
void create_hard_link(const path&, const path&, error_code&) _NOEXCEPT;

void create_symlink(const path&, const path&);
void create_symlink(const path&, const path&, error_code&) _NOEXCEPT;

path current_path();
path current_path(error_code&);
void current_path(const path&);
void current_path(const path&, error_code&) _NOEXCEPT;

bool exists(file_status) _NOEXCEPT;
bool exists(const path&);
bool exists(const path&, error_code&) _NOEXCEPT;

bool equivalent(const path&, const path&);
bool equivalent(const path&, const path&, error_code&) _NOEXCEPT;

uintmax_t file_size(const path&);
uintmax_t file_size(const path&, error_code&) _NOEXCEPT;

uintmax_t hard_link_count(const path&);
uintmax_t hard_link_count(const path&, error_code&) _NOEXCEPT;

bool is_block_file(file_status) _NOEXCEPT;
bool is_block_file(const path&);
bool is_block_file(const path&, error_code&) _NOEXCEPT;

bool is_character_file(file_status) _NOEXCEPT;
bool is_character_file(const path&);
bool is_character_file(const path&, error_code&) _NOEXCEPT;

bool is_directory(file_status) _NOEXCEPT;
bool is_directory(const path&);
bool is_directory(const path&, error_code&) _NOEXCEPT;

bool is_empty(const path&);
bool is_empty(const path&, error_code&) _NOEXCEPT;

bool is_fifo(file_status) _NOEXCEPT;
bool is_fifo(const path&);
bool is_fifo(const path&, error_code&) _NOEXCEPT;

bool is_other(file_status) _NOEXCEPT;
bool is_other(const path&);
bool is_other(const path&, error_code&) _NOEXCEPT;

bool is_regular_file(file_status) _NOEXCEPT;
bool is_regular_file(const path&);
bool is_regular_file(const path&, error_code&) _NOEXCEPT;

bool is_socket(file_status) _NOEXCEPT;
bool is_socket(const path&);
bool is_socket(const path&, error_code&) _NOEXCEPT;

bool is_symlink(file_status) _NOEXCEPT;
bool is_symlink(const path&);
bool is_symlink(const path&, error_code&) _NOEXCEPT;

file_time_type last_write_time(const path&);
file_time_type last_write_time(const path&, error_code&) _NOEXCEPT;
void last_write_time(const path&, file_time_type);
void last_write_time(const path&, file_time_type, error_code&) _NOEXCEPT;

void permissions(const path&, perms);
void permissions(const path&, perms, error_code&) _NOEXCEPT;

path read_symlink(const path&);
path read_symlink(const path&, error_code&);

bool remove(const path&);
bool remove(const path&, error_code&) _NOEXCEPT;

uintmax_t remove_all(const path&);
uintmax_t remove_all(const path&, error_code&) _NOEXCEPT;

void rename(const path&, const path&);
void rename(const path&, const path&, error_code&) _NOEXCEPT;

void resize_file(const path&, uintmax_t);
void resize_file(const path&, uintmax_t, error_code&) _NOEXCEPT;

space_info space(const path&);
space_info space(const path&, error_code&) _NOEXCEPT;

file_status status(const path&);
file_status status(const path&, error_code&) _NOEXCEPT;

bool status_known(file_status) _NOEXCEPT;

file_status symlink_status(const path&);
file_status symlink_status(const path&, error_code&) _NOEXCEPT;

path system_complete(const path&);
path system_complete(const path&, error_code&);

path temp_directory_path();
path temp_directory_path(error_code&);


class directory_entry
{
private:
    typedef _VSTD_FS::path _Path;

public:
    // constructors and destructors
    directory_entry() _NOEXCEPT = default;
    directory_entry(directory_entry const&) = default;
    directory_entry(directory_entry&&) _NOEXCEPT = default;

    _LIBCPP_INLINE_VISIBILITY
    explicit directory_entry(_Path const& __p) : __p_(__p) {}

    ~directory_entry() {}

    directory_entry& operator=(directory_entry const&) = default;
    directory_entry& operator=(directory_entry&&) _NOEXCEPT = default;

    _LIBCPP_INLINE_VISIBILITY
    void assign(_Path const& __p) {
        __p_ = __p;
    }

    _LIBCPP_INLINE_VISIBILITY
    void replace_filename(_Path const& __p) {
        __p_ = __p_.parent_path() / __p;
    }

    _LIBCPP_INLINE_VISIBILITY
    _Path const& path() const _NOEXCEPT {
        return __p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    operator const _Path&() const _NOEXCEPT {
        return __p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    file_status status() const {
        return _VSTD_FS::status(__p_);
    }

    _LIBCPP_INLINE_VISIBILITY
    file_status status(error_code& __ec) const _NOEXCEPT {
        return _VSTD_FS::status(__p_, __ec);
    }

    _LIBCPP_INLINE_VISIBILITY
    file_status symlink_status() const {
        return _VSTD_FS::symlink_status(__p_);
    }

    _LIBCPP_INLINE_VISIBILITY
    file_status symlink_status(error_code& __ec) const _NOEXCEPT {
        return _VSTD_FS::symlink_status(__p_, __ec);
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator< (directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ < __rhs.__p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator==(directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ == __rhs.__p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator!=(directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ != __rhs.__p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator<=(directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ <= __rhs.__p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator> (directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ > __rhs.__p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator>=(directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ >= __rhs.__p_;
    }
private:
    _Path __p_;
};


class directory_iterator;
class recursive_directory_iterator;
class __dir_stream;

class directory_iterator
{
public:
    typedef directory_entry value_type;
    typedef ptrdiff_t difference_type;
    typedef value_type const* pointer;
    typedef value_type const& reference;
    typedef input_iterator_tag iterator_category;

public:
    //ctor & dtor
    directory_iterator() _NOEXCEPT
    { }

    explicit directory_iterator(const path& __p)
        : directory_iterator(__p, nullptr)
    { }

    directory_iterator(const path& __p, error_code& __ec) _NOEXCEPT
        : directory_iterator(__p, &__ec)
    { }

    directory_iterator(const directory_iterator&) = default;
    directory_iterator(directory_iterator&&) = default;
    directory_iterator& operator=(const directory_iterator&) = default;
    directory_iterator& operator=(directory_iterator&&) = default;
    ~directory_iterator() = default;

    const directory_entry& operator*() const
    { return __elem_; }

    const directory_entry* operator->() const
    { return &__elem_; }

    directory_iterator& operator++()
    { return __increment(); }

    directory_iterator operator++(int)
    {
        directory_iterator __it(*this);
        __increment();
        return __it;
    }

    directory_iterator& increment(error_code& __ec) _NOEXCEPT
    { return __increment(&__ec); }

    bool operator==(const directory_iterator& __rhs) const _NOEXCEPT
    { return __stream_.get() == __rhs.__stream_.get(); }

    bool operator!=(const directory_iterator& __rhs) const _NOEXCEPT
    { return !(*this == __rhs); }

private:
    // recursive_directory_iterator uses this class
    // as its underlying implementation, and therefore it
    // needs access to the methods that take an optional error_code
    friend class recursive_directory_iterator;

    // construct the dir_stream
    directory_iterator(const path&, error_code *);
    directory_iterator& __increment(error_code * __ec = nullptr);
    // convert iterator into end iterator
    void __make_end();

private:
    shared_ptr<__dir_stream> __stream_;
    path __root_path_;
    directory_entry __elem_;
};

// enable directory_iterator range-based for statements
inline _LIBCPP_INLINE_VISIBILITY
directory_iterator begin(directory_iterator __iter) _NOEXCEPT
{
    return __iter;
}

inline _LIBCPP_INLINE_VISIBILITY
directory_iterator end(const directory_iterator&) _NOEXCEPT
{
    return directory_iterator();
}

class recursive_directory_iterator
    {
    public:
        using value_type = directory_entry;
        using difference_type = std::ptrdiff_t;
        using pointer = directory_entry const *;
        using reference = directory_entry const &;
        using iterator_category = std::input_iterator_tag;

    public:
        // constructors and destructor
        recursive_directory_iterator() _NOEXCEPT
        {}

        explicit recursive_directory_iterator(const path& p,
                    directory_options xoptions = directory_options::none)
            : recursive_directory_iterator(p, xoptions,  nullptr)
        { }

        recursive_directory_iterator(const path& p,
            directory_options xoptions, std::error_code& ec) _NOEXCEPT
            : recursive_directory_iterator(p, xoptions, &ec)
        { }

        recursive_directory_iterator(const path& p, std::error_code& ec) _NOEXCEPT
            : recursive_directory_iterator(p, directory_options::none,  &ec)
        { }

        recursive_directory_iterator(const recursive_directory_iterator&) = default;
        recursive_directory_iterator(recursive_directory_iterator&&) = default;

        recursive_directory_iterator & 
        operator=(const recursive_directory_iterator&) = default;

        recursive_directory_iterator & 
        operator=(recursive_directory_iterator&&) = default;

        ~recursive_directory_iterator() = default;

        ////////////////////////////////////////////////////////////////////////
        //
        const directory_entry& operator*() const
        { return __entry_; }

        const directory_entry* operator->() const
        { return &__entry_; }

        ////////////////////////////////////////////////////////////////////////
        recursive_directory_iterator& operator++()
        { return __increment(); }

        recursive_directory_iterator operator++(int)
        {
            auto cp = *this;
            __increment();
            return cp;
        }
        
        recursive_directory_iterator& increment(std::error_code& ec)
        { return __increment(&ec); }

        ////////////////////////////////////////////////////////////////////////
        directory_options options() const _NOEXCEPT
        { return __options_; }
        
        ////////////////////////////////////////////////////////////////////////
        int depth() const
        {
            // __stack_ptr_ && __stack_ptr_->size() == 0 should
            // never be true
            return (__stack_ptr_ ? static_cast<int>(__stack_ptr_->size() - 1) : 0); 
        }
        
        ////////////////////////////////////////////////////////////////////////
        bool recursion_pending() const _NOEXCEPT
        { return __rec_; }
           
        ////////////////////////////////////////////////////////////////////////
        void pop()
        {
            if (!__stack_ptr_) return;
            _LIBCPP_ASSERT(__stack_ptr_->size() > 0, "Popping an empty stack");
            __stack_ptr_->top() = directory_iterator();
            __increment();
        }
        
        ////////////////////////////////////////////////////////////////////////
        void disable_recursion_pending() _NOEXCEPT
        { __rec_ = false; }
        
        ////////////////////////////////////////////////////////////////////////
        bool operator==(const recursive_directory_iterator& other) const _NOEXCEPT
        { return __stack_ptr_ == other.__stack_ptr_; }
        
        ////////////////////////////////////////////////////////////////////////
        bool operator!=(const recursive_directory_iterator& other) const _NOEXCEPT
        { return !(*this == other);}
    
    private:
        recursive_directory_iterator(const path& __p, directory_options __opt,
                                     error_code *__ec);

        void __make_end();
        bool ___try_recursion(error_code *ec);
        recursive_directory_iterator& __increment(error_code *__ec=nullptr);

        shared_ptr<stack<directory_iterator>> __stack_ptr_{nullptr};
        directory_entry __entry_;
        directory_options __options_{directory_options::none};
        bool __rec_{true};
    };                                     // class recursive_directory_iterator

// enable recursive_directory_iterator range-based for statements
inline _LIBCPP_INLINE_VISIBILITY
recursive_directory_iterator begin(recursive_directory_iterator __iter) _NOEXCEPT
{
    return __iter;
}

inline _LIBCPP_INLINE_VISIBILITY
recursive_directory_iterator end(const recursive_directory_iterator&) _NOEXCEPT
{
    return recursive_directory_iterator();
}


_LIBCPP_END_NAMESPACE_EXPERIMENTAL_FILESYSTEM

#endif // _LIBCPP_EXPERIMENTAL_FILESYSTEM
