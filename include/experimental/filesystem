// -*- C++ -*-
//===--------------------------- filesystem -------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
#ifndef _LIBCPP_EXPERIMENTAL_FILESYSTEM
#define _LIBCPP_EXPERIMENTAL_FILESYSTEM
/*
    filesystem synopsis

    namespace std { namespace experimental { namespace filesystem { inline namespace v1 {

    class path;

    void swap(path& lhs, path& rhs) _NOEXCEPT;
    size_t hash_value(const path& p) _NOEXCEPT;

    bool operator==(const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator!=(const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator< (const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator<=(const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator> (const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator>=(const path& lhs, const path& rhs) _NOEXCEPT;

    path operator/ (const path& lhs, const path& rhs);

    template <class charT, class traits>
    basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const path& p);

    template <class charT, class traits>
    basic_istream<charT, traits>&
    operator>>(basic_istream<charT, traits>& is, path& p);

    template <class Source>  
      path u8path(const Source& source);
    template <class InputIterator>
      path u8path(InputIterator first, InputIterator last);

    class filesystem_error;      
    class directory_entry;

    class directory_iterator;

    // enable directory_iterator range-based for statements
    directory_iterator begin(directory_iterator iter) _NOEXCEPT;
    directory_iterator end(const directory_iterator&) _NOEXCEPT;

    class recursive_directory_iterator;

    // enable recursive_directory_iterator range-based for statements
    recursive_directory_iterator begin(recursive_directory_iterator iter) _NOEXCEPT;
    recursive_directory_iterator end(const recursive_directory_iterator&) _NOEXCEPT;

    class file_status;

    struct space_info
    {
      uintmax_t capacity;
      uintmax_t free; 
      uintmax_t available;
    };

    enum class file_type;
    enum class perms;
    enum class copy_options;
    enum class directory_options;

    typedef chrono::time_point<trivial-clock>  file_time_type;

    // operational functions

    path absolute(const path& p, const path& base=current_path());

    path canonical(const path& p, const path& base = current_path());
    path canonical(const path& p, error_code& ec);
    path canonical(const path& p, const path& base, error_code& ec);

    void copy(const path& from, const path& to);
    void copy(const path& from, const path& to, error_code& ec) _NOEXCEPT;
    void copy(const path& from, const path& to, copy_options options);
    void copy(const path& from, const path& to, copy_options options,  
                   error_code& ec) _NOEXCEPT;

    bool copy_file(const path& from, const path& to);
    bool copy_file(const path& from, const path& to, error_code& ec) _NOEXCEPT;
    bool copy_file(const path& from, const path& to, copy_options option);
    bool copy_file(const path& from, const path& to, copy_options option,
                           error_code& ec) _NOEXCEPT;

    void copy_symlink(const path& existing_symlink, const path& new_symlink);
    void copy_symlink(const path& existing_symlink, const path& new_symlink,
                              error_code& ec) _NOEXCEPT;

    bool create_directories(const path& p);
    bool create_directories(const path& p, error_code& ec) _NOEXCEPT;

    bool create_directory(const path& p);
    bool create_directory(const path& p, error_code& ec) _NOEXCEPT;

    bool create_directory(const path& p, const path& attributes);
    bool create_directory(const path& p, const path& attributes,
                                  error_code& ec) _NOEXCEPT;

    void create_directory_symlink(const path& to, const path& new_symlink);
    void create_directory_symlink(const path& to, const path& new_symlink,
                                          error_code& ec) _NOEXCEPT;

    void create_hard_link(const path& to, const path& new_hard_link);
    void create_hard_link(const path& to, const path& new_hard_link,
                                  error_code& ec) _NOEXCEPT;

    void create_symlink(const path& to, const path& new_symlink);
    void create_symlink(const path& to, const path& new_symlink,
                                error_code& ec) _NOEXCEPT;

    path current_path();
    path current_path(error_code& ec);
    void current_path(const path& p);
    void current_path(const path& p, error_code& ec) _NOEXCEPT;

    bool exists(file_status s) _NOEXCEPT;
    bool exists(const path& p);
    bool exists(const path& p, error_code& ec) _NOEXCEPT;

    bool equivalent(const path& p1, const path& p2);
    bool equivalent(const path& p1, const path& p2, error_code& ec) _NOEXCEPT;

    uintmax_t    file_size(const path& p);
    uintmax_t    file_size(const path& p, error_code& ec) _NOEXCEPT;

    uintmax_t    hard_link_count(const path& p);
    uintmax_t    hard_link_count(const path& p, error_code& ec) _NOEXCEPT;

    bool is_block_file(file_status s) _NOEXCEPT;
    bool is_block_file(const path& p);
    bool is_block_file(const path& p, error_code& ec) _NOEXCEPT;

    bool is_character_file(file_status s) _NOEXCEPT;
    bool is_character_file(const path& p);
    bool is_character_file(const path& p, error_code& ec) _NOEXCEPT;

    bool is_directory(file_status s) _NOEXCEPT;
    bool is_directory(const path& p);
    bool is_directory(const path& p, error_code& ec) _NOEXCEPT;

    bool is_empty(const path& p);
    bool is_empty(const path& p, error_code& ec) _NOEXCEPT;

    bool is_fifo(file_status s) _NOEXCEPT;
    bool is_fifo(const path& p);
    bool is_fifo(const path& p, error_code& ec) _NOEXCEPT;

    bool is_other(file_status s) _NOEXCEPT;
    bool is_other(const path& p);
    bool is_other(const path& p, error_code& ec) _NOEXCEPT;

    bool is_regular_file(file_status s) _NOEXCEPT; 
    bool is_regular_file(const path& p);
    bool is_regular_file(const path& p, error_code& ec) _NOEXCEPT;

    bool is_socket(file_status s) _NOEXCEPT;
    bool is_socket(const path& p);
    bool is_socket(const path& p, error_code& ec) _NOEXCEPT;

    bool is_symlink(file_status s) _NOEXCEPT;
    bool is_symlink(const path& p);
    bool is_symlink(const path& p, error_code& ec) _NOEXCEPT;

    file_time_type  last_write_time(const path& p);
    file_time_type  last_write_time(const path& p, error_code& ec) _NOEXCEPT;
    void last_write_time(const path& p, file_time_type new_time);
    void last_write_time(const path& p, file_time_type new_time,
                                 error_code& ec) _NOEXCEPT;

    void permissions(const path& p, perms prms);
    void permissions(const path& p, perms prms, error_code& ec) _NOEXCEPT;

    path read_symlink(const path& p);
    path read_symlink(const path& p, error_code& ec);

    bool remove(const path& p);
    bool remove(const path& p, error_code& ec) _NOEXCEPT;

    uintmax_t    remove_all(const path& p);
    uintmax_t    remove_all(const path& p, error_code& ec) _NOEXCEPT;

    void rename(const path& from, const path& to);
    void rename(const path& from, const path& to, error_code& ec) _NOEXCEPT;

    void resize_file(const path& p, uintmax_t size);
    void resize_file(const path& p, uintmax_t size, error_code& ec) _NOEXCEPT;

    space_info   space(const path& p);
    space_info   space(const path& p, error_code& ec) _NOEXCEPT;

    file_status  status(const path& p);
    file_status  status(const path& p, error_code& ec) _NOEXCEPT;

    bool status_known(file_status s) _NOEXCEPT;

    file_status  symlink_status(const path& p);
    file_status  symlink_status(const path& p, error_code& ec) _NOEXCEPT;

    path system_complete(const path& p);
    path system_complete(const path& p, error_code& ec);

    path temp_directory_path();
    path temp_directory_path(error_code& ec);

} } } }  // namespaces std::experimental::filesystem::v1

*/

#include <experimental/__config>
#include <cstddef>
#include <chrono>
#include <iterator>
#include <iosfwd>
#include <locale>
#include <memory>
#include <string>
#include <system_error>
#include <utility>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_FILESYSTEM


typedef chrono::time_point<std::chrono::system_clock>  file_time_type;

struct _LIBCPP_TYPE_VIS space_info
{
  uintmax_t capacity;
  uintmax_t free;
  uintmax_t available;
};

enum class file_type
{
    none = 0,
    not_found = -1,
    regular = 1,
    directory = 2,
    symlink = 3,
    block = 4,
    character = 5,
    fifo = 6,
    socket = 7,
    unknown = 8
};

enum class perms
{
    none = 0,

    owner_read   = 0400,
    owner_write  = 0200,
    owner_exec   = 0100,
    owner_all    = 0700,

    group_read   = 040,
    group_write  = 020,
    group_exec   = 010,
    group_all    = 070,

    others_read  = 04,
    others_write = 02,
    others_exec  = 01,
    others_all   = 07,

    all          = 0777,

    set_uid      = 04000,
    set_gid      = 02000,
    sticky_bit   = 01000,
    mask         = 07777,
    unknown      = 0xFFFF,

    add_perms        = 0x10000,
    remove_perms     = 0x20000,
    resolve_symlinks = 0x40000
};

enum class copy_options
{
    none               = 0,
    skip_existing      = 1,
    overwrite_existing = 2,
    update_existing    = 4,
    recursive          = 8,
    copy_symlinks      = 16,
    skip_symlinks      = 32,
    directories_only   = 64,
    create_symlinks    = 128,
    create_hard_links  = 256
};

enum class directory_options
{
    none = 0,
    follow_directory_symlink = 1,
    skip_permission_denied = 2
};

class _LIBCPP_TYPE_VIS file_status
{
public:
    // constructors
    _LIBCPP_INLINE_VISIBILITY
    explicit file_status(file_type __ft = file_type::none,
                         perms __prms = perms::unknown) _NOEXCEPT
      : __ft_(__ft), __prms_(__prms)
    {}

    file_status(const file_status&) _NOEXCEPT = default;
    file_status(file_status&&) _NOEXCEPT = default;

    _LIBCPP_INLINE_VISIBILITY
    ~file_status() {}

    file_status& operator=(const file_status&) _NOEXCEPT = default;
    file_status& operator=(file_status&&) _NOEXCEPT = default;

    // observers
    _LIBCPP_ALWAYS_INLINE
    file_type type() const _NOEXCEPT {
        return __ft_;
    }

    _LIBCPP_ALWAYS_INLINE
    perms permissions() const _NOEXCEPT {
        return __prms_;
    }

    // modifiers
    _LIBCPP_ALWAYS_INLINE
    void type(file_type __ft) _NOEXCEPT {
        __ft_ = __ft;
    }

    _LIBCPP_ALWAYS_INLINE
    void permissions(perms __p) _NOEXCEPT {
        __prms_ = __p;
    }
private:
    file_type __ft_;
    perms __prms_;
};

class _LIBCPP_TYPE_VIS path
{
public:
    typedef char value_type;
    typedef basic_string<value_type> string_type;
    static _LIBCPP_CONSTEXPR value_type preferred_separator = '/';

    // constructors and destructor
    _LIBCPP_INLINE_VISIBILITY
    path() _NOEXCEPT {}

    _LIBCPP_INLINE_VISIBILITY
    path(const path& __p) : __pn_(__p.__pn_) {}

    _LIBCPP_INLINE_VISIBILITY
    path(path&& __p) _NOEXCEPT : __pn_(_VSTD::move(__p.__pn_)) {}

    template <class _Source>
        path(const _Source& __src);
    template <class _InputIt>
        path(_InputIt __first, _InputIt __last);
    template <class _Source>
        path(const _Source& __src, const locale& __loc);
    template <class _InputIt>
        path(_InputIt __first, _InputIt _last, const locale& __loc);

    _LIBCPP_INLINE_VISIBILITY
    ~path() {}

    // assignments
    _LIBCPP_INLINE_VISIBILITY
    path& operator=(const path& __p) {
        __pn_ = __p.__pn_;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator=(path&& __p) _NOEXCEPT {
        __pn_ = _VSTD::move(__p.__pn_);
        return *this;
    }

    template <class _Source>
        path& operator=(const _Source& __src);
    template <class _Source>
        path& assign(const _Source& __src);
    template <class _InputIt>
        path& assign(_InputIt __first, _InputIt __last);

    // appends
    path& operator/=(const path& __p);
    template <class _Source>
        path& operator/=(const _Source& __src);
    template <class _Source>
        path& append(const _Source& __src);
    template <class _InputIt>
        path& append(_InputIt __first, _InputIt __last);

    // concatenation
    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(const path& __x) {
        __pn_ += __x.__pn_;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(const string_type& __x) {
        __pn_ += __x;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(const value_type* __x) {
        __pn_ += __x;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(value_type __x) {
        __pn_ += __x;
        return *this;
    }

    template <class _Source>
        path& operator+=(const _Source& __x);
    template <class _EcharT>
        path& operator+=(_EcharT __x);
    template <class _Source>
        path& concat(const _Source& __x);
    template <class _InputIt>
        path& concat(_InputIt __first, _InputIt __last);

    // modifiers
    _LIBCPP_INLINE_VISIBILITY
    void  clear() _NOEXCEPT {
        __pn_.clear();
    }

    path& make_preferred();
    path& remove_filename();
    path& replace_filename(const path& __replacement);
    path& replace_extension(const path& __replacement = path());

    _LIBCPP_INLINE_VISIBILITY
    void  swap(path& __rhs) _NOEXCEPT {
        __pn_.swap(__rhs.__pn_);
    }

    // native format observers
    _LIBCPP_INLINE_VISIBILITY
    const string_type& native() const _NOEXCEPT {
        return __pn_;
    }

    _LIBCPP_INLINE_VISIBILITY
    const value_type*   c_str() const _NOEXCEPT {
        return __pn_.c_str();
    }

    _LIBCPP_INLINE_VISIBILITY
    operator string_type() const {
        return __pn_;
    }

    template <class _EcharT, class _Traits = char_traits<_EcharT>,
              class _Allocator = allocator<_EcharT> >
    basic_string<_EcharT, _Traits, _Allocator>
        string(const _Allocator& __a = _Allocator()) const;

    _LIBCPP_INLINE_VISIBILITY
    std::string string() const {
        return __pn_;
    }

    std::wstring wstring() const;
    std::string  u8string() const;
    std::u16string u16string() const;
    std::u32string u32string() const;

    // generic format observers
    template <class _EcharT, class _Traits = char_traits<_EcharT>,
              class _Allocator = allocator<_EcharT> >
    basic_string<_EcharT, _Traits, _Allocator>
        generic_string(const _Allocator& __a = _Allocator()) const;
    std::string    generic_string() const;
    std::wstring   generic_wstring() const;
    std::string    generic_u8string() const;
    std::u16string generic_u16string() const;
    std::u32string generic_u32string() const;

    // compare
    _LIBCPP_INLINE_VISIBILITY
    int compare(const path& __p) const _NOEXCEPT {
        return __pn_.compare(__p.__pn_);
    }

    _LIBCPP_INLINE_VISIBILITY
    int compare(const string_type& __s) const {
        return __pn_.compare(__s);
    }

    _LIBCPP_INLINE_VISIBILITY
    int compare(const value_type* __s) const {
        return __pn_.compare(__s);
    }

    // decomposition
    path root_name() const;
    path root_directory() const;
    path root_path() const;
    path relative_path() const;
    path parent_path() const;
    path filename() const;
    path stem() const;
    path extension() const;

    // query
    _LIBCPP_INLINE_VISIBILITY
    bool empty() const _NOEXCEPT {
        return __pn_.empty();
    }

    bool has_root_name() const;
    bool has_root_directory() const;
    bool has_root_path() const;
    bool has_relative_path() const;
    bool has_parent_path() const;
    bool has_filename() const;
    bool has_stem() const;
    bool has_extension() const;
    bool is_absolute() const;
    bool is_relative() const;

    // iterators
    class iterator;
    typedef iterator const_iterator;

    iterator begin() const;
    iterator end() const;

private:
    string_type __pn_;
};


inline _LIBCPP_ALWAYS_INLINE
void swap(path& __lhs, path& __rhs) _NOEXCEPT
{
    __lhs.swap(__rhs);
}

inline _LIBCPP_INLINE_VISIBILITY
size_t hash_value(const path& __p) _NOEXCEPT
{
    hash<path::string_type> __h;
    return __h(__p.native());
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator==(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) == 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) != 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator<(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) < 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator<=(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) <= 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator>(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) > 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator>=(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) >= 0;
}

inline _LIBCPP_INLINE_VISIBILITY
path operator/(const path& __lhs, const path& __rhs)
{
    return path(__lhs) /= __rhs;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p);

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, path& __p);

template <class _Source>
  path u8path(const _Source&);
template <class _InputIt>
  path u8path(_InputIt, _InputIt);


class _LIBCPP_TYPE_VIS path::iterator
    : public std::iterator<bidirectional_iterator_tag, path>
{
public:
    _LIBCPP_INLINE_VISIBILITY
    iterator() : __elem_(), __path_ptr_(nullptr), __pos_(0) {}

    iterator(const iterator&) = default;
    iterator(iterator&&) = default;
    ~iterator() = default;

    iterator& operator=(const iterator&) = default;
    iterator& operator=(iterator&&) = default;

    _LIBCPP_INLINE_VISIBILITY
    const path& operator*() const {
        return &__elem_;
    }

    _LIBCPP_INLINE_VISIBILITY
    const path& operator->() const {
        return &__elem_;
    }

    iterator& operator++();

    _LIBCPP_INLINE_VISIBILITY
    iterator operator++(int) {
        iterator __it(*this);
        this->operator++();
        return __it;
    }

    iterator& operator--();

    _LIBCPP_INLINE_VISIBILITY
    iterator operator--(int) {
        iterator __it(*this);
        this->operator--();
        return __it;
    }
private:
    friend bool operator==(const iterator&, const iterator&);

    path __elem_;
    const path* __path_ptr_;
    size_t __pos_;
};

inline _LIBCPP_INLINE_VISIBILITY
bool operator==(const path::iterator& __lhs, const path::iterator& __rhs)
{
    return __lhs.__path_ptr_ == __rhs.__path_ptr_ &&
           __lhs.__pos_ == __rhs.__pos_;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(const path::iterator& __lhs, const path::iterator& __rhs)
{
    return !(__lhs == __rhs);
}


class _LIBCPP_EXCEPTION_ABI filesystem_error : public system_error
{
public:
    _LIBCPP_INLINE_VISIBILITY
    filesystem_error(const string& __what, error_code __ec)
        : system_error(__ec, __what),
          __paths_(make_shared<_Storage>(path(), path()))
    {}

    _LIBCPP_INLINE_VISIBILITY
    filesystem_error(const string& __what, const path& __p1, error_code __ec)
        : system_error(__ec, __what),
        __paths_(make_shared<_Storage>(__p1, path()))
    {}

    _LIBCPP_INLINE_VISIBILITY
    filesystem_error(const string& __what, const path& __p1, const path& __p2,
                     error_code __ec)
        : system_error(__ec, __what),
          __paths_(make_shared<_Storage>(__p1, __p2))
    {}

    _LIBCPP_INLINE_VISIBILITY
    const path& path1() const _NOEXCEPT {
        return __paths_->first;
    }

    _LIBCPP_INLINE_VISIBILITY
    const path& path2() const _NOEXCEPT {
        return __paths_->second;
    }

    // TODO(ericwf): Create a custom error message.
    //const char* what() const _NOEXCEPT;

private:
    typedef pair<path, path> _Storage;
    shared_ptr<_Storage> __paths_;
};

class directory_entry;

class directory_iterator;

// enable directory_iterator range-based for statements
directory_iterator begin(directory_iterator) _NOEXCEPT;
directory_iterator end(const directory_iterator&) _NOEXCEPT;

class recursive_directory_iterator;

// enable recursive_directory_iterator range-based for statements
recursive_directory_iterator begin(recursive_directory_iterator) _NOEXCEPT;
recursive_directory_iterator end(const recursive_directory_iterator&) _NOEXCEPT;


// operational functions

path absolute(const path&);
path absolute(const path&, const path&);

path canonical(const path&);
path canonical(const path&, const path&);
path canonical(const path&, error_code&);
path canonical(const path&, const path&, error_code&);

void copy(const path&, const path&);
void copy(const path&, const path&, error_code&) _NOEXCEPT;
void copy(const path&, const path&, copy_options);
void copy(const path&, const path&, copy_options, error_code&) _NOEXCEPT;

bool copy_file(const path&, const path&);
bool copy_file(const path&, const path&, error_code&) _NOEXCEPT;
bool copy_file(const path&, const path&, copy_options);
bool copy_file(const path&, const path&, copy_options, error_code&) _NOEXCEPT;

void copy_symlink(const path&, const path&);
void copy_symlink(const path&, const path&, error_code&) _NOEXCEPT;

bool create_directories(const path&);
bool create_directories(const path&, error_code&) _NOEXCEPT;

bool create_directory(const path&);
bool create_directory(const path&, error_code&) _NOEXCEPT;

bool create_directory(const path&, const path&);
bool create_directory(const path&, const path&, error_code&) _NOEXCEPT;

void create_directory_symlink(const path&, const path&);
void create_directory_symlink(const path&, const path&, error_code&) _NOEXCEPT;

void create_hard_link(const path&, const path&);
void create_hard_link(const path&, const path&, error_code&) _NOEXCEPT;

void create_symlink(const path&, const path&);
void create_symlink(const path&, const path&, error_code&) _NOEXCEPT;

path current_path();
path current_path(error_code&);
void current_path(const path&);
void current_path(const path&, error_code&) _NOEXCEPT;

bool exists(file_status) _NOEXCEPT;
bool exists(const path&);
bool exists(const path&, error_code&) _NOEXCEPT;

bool equivalent(const path&, const path&);
bool equivalent(const path&, const path&, error_code&) _NOEXCEPT;

uintmax_t file_size(const path&);
uintmax_t file_size(const path&, error_code&) _NOEXCEPT;

uintmax_t hard_link_count(const path&);
uintmax_t hard_link_count(const path&, error_code&) _NOEXCEPT;

bool is_block_file(file_status) _NOEXCEPT;
bool is_block_file(const path&);
bool is_block_file(const path&, error_code&) _NOEXCEPT;

bool is_character_file(file_status) _NOEXCEPT;
bool is_character_file(const path&);
bool is_character_file(const path&, error_code&) _NOEXCEPT;

bool is_directory(file_status) _NOEXCEPT;
bool is_directory(const path&);
bool is_directory(const path&, error_code&) _NOEXCEPT;

bool is_empty(const path&);
bool is_empty(const path&, error_code&) _NOEXCEPT;

bool is_fifo(file_status) _NOEXCEPT;
bool is_fifo(const path&);
bool is_fifo(const path&, error_code&) _NOEXCEPT;

bool is_other(file_status) _NOEXCEPT;
bool is_other(const path&);
bool is_other(const path&, error_code&) _NOEXCEPT;

bool is_regular_file(file_status) _NOEXCEPT;
bool is_regular_file(const path&);
bool is_regular_file(const path&, error_code&) _NOEXCEPT;

bool is_socket(file_status) _NOEXCEPT;
bool is_socket(const path&);
bool is_socket(const path&, error_code&) _NOEXCEPT;

bool is_symlink(file_status) _NOEXCEPT;
bool is_symlink(const path&);
bool is_symlink(const path&, error_code&) _NOEXCEPT;

file_time_type last_write_time(const path&);
file_time_type last_write_time(const path&, error_code&) _NOEXCEPT;
void last_write_time(const path&, file_time_type);
void last_write_time(const path&, file_time_type, error_code&) _NOEXCEPT;

void permissions(const path&, perms);
void permissions(const path&, perms, error_code&) _NOEXCEPT;

path read_symlink(const path&);
path read_symlink(const path&, error_code&);

bool remove(const path&);
bool remove(const path&, error_code&) _NOEXCEPT;

uintmax_t remove_all(const path&);
uintmax_t remove_all(const path&, error_code&) _NOEXCEPT;

void rename(const path&, const path&);
void rename(const path&, const path&, error_code&) _NOEXCEPT;

void resize_file(const path&, uintmax_t);
void resize_file(const path&, uintmax_t, error_code&) _NOEXCEPT;

space_info space(const path&);
space_info space(const path&, error_code&) _NOEXCEPT;

file_status status(const path&);
file_status status(const path&, error_code&) _NOEXCEPT;

bool status_known(file_status) _NOEXCEPT;

file_status symlink_status(const path&);
file_status symlink_status(const path&, error_code&) _NOEXCEPT;

path system_complete(const path&);
path system_complete(const path&, error_code&);

path temp_directory_path();
path temp_directory_path(error_code&);

_LIBCPP_END_NAMESPACE_EXPERIMENTAL_FILESYSTEM

#endif // _LIBCPP_EXPERIMENTAL_FILESYSTEM
