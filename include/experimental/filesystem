// -*- C++ -*-
//===--------------------------- filesystem -------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
#ifndef _LIBCPP_EXPERIMENTAL_FILESYSTEM
#define _LIBCPP_EXPERIMENTAL_FILESYSTEM
/*
    filesystem synopsis

    namespace std { namespace experimental { namespace filesystem { inline namespace v1 {

    class path;

    void swap(path& lhs, path& rhs) _NOEXCEPT;
    size_t hash_value(const path& p) _NOEXCEPT;

    bool operator==(const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator!=(const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator< (const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator<=(const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator> (const path& lhs, const path& rhs) _NOEXCEPT;
    bool operator>=(const path& lhs, const path& rhs) _NOEXCEPT;

    path operator/ (const path& lhs, const path& rhs);

    template <class charT, class traits>
    basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const path& p);

    template <class charT, class traits>
    basic_istream<charT, traits>&
    operator>>(basic_istream<charT, traits>& is, path& p);

    template <class Source>  
      path u8path(const Source& source);
    template <class InputIterator>
      path u8path(InputIterator first, InputIterator last);

    class filesystem_error;      
    class directory_entry;

    class directory_iterator;

    // enable directory_iterator range-based for statements
    directory_iterator begin(directory_iterator iter) _NOEXCEPT;
    directory_iterator end(const directory_iterator&) _NOEXCEPT;

    class recursive_directory_iterator;

    // enable recursive_directory_iterator range-based for statements
    recursive_directory_iterator begin(recursive_directory_iterator iter) _NOEXCEPT;
    recursive_directory_iterator end(const recursive_directory_iterator&) _NOEXCEPT;

    class file_status;

    struct space_info
    {
      uintmax_t capacity;
      uintmax_t free; 
      uintmax_t available;
    };

    enum class file_type;
    enum class perms;
    enum class copy_options;
    enum class directory_options;

    typedef chrono::time_point<trivial-clock>  file_time_type;

    // operational functions

    path absolute(const path& p, const path& base=current_path());

    path canonical(const path& p, const path& base = current_path());
    path canonical(const path& p, error_code& ec);
    path canonical(const path& p, const path& base, error_code& ec);

    void copy(const path& from, const path& to);
    void copy(const path& from, const path& to, error_code& ec) _NOEXCEPT;
    void copy(const path& from, const path& to, copy_options options);
    void copy(const path& from, const path& to, copy_options options,  
                   error_code& ec) _NOEXCEPT;

    bool copy_file(const path& from, const path& to);
    bool copy_file(const path& from, const path& to, error_code& ec) _NOEXCEPT;
    bool copy_file(const path& from, const path& to, copy_options option);
    bool copy_file(const path& from, const path& to, copy_options option,
                           error_code& ec) _NOEXCEPT;

    void copy_symlink(const path& existing_symlink, const path& new_symlink);
    void copy_symlink(const path& existing_symlink, const path& new_symlink,
                              error_code& ec) _NOEXCEPT;

    bool create_directories(const path& p);
    bool create_directories(const path& p, error_code& ec) _NOEXCEPT;

    bool create_directory(const path& p);
    bool create_directory(const path& p, error_code& ec) _NOEXCEPT;

    bool create_directory(const path& p, const path& attributes);
    bool create_directory(const path& p, const path& attributes,
                                  error_code& ec) _NOEXCEPT;

    void create_directory_symlink(const path& to, const path& new_symlink);
    void create_directory_symlink(const path& to, const path& new_symlink,
                                          error_code& ec) _NOEXCEPT;

    void create_hard_link(const path& to, const path& new_hard_link);
    void create_hard_link(const path& to, const path& new_hard_link,
                                  error_code& ec) _NOEXCEPT;

    void create_symlink(const path& to, const path& new_symlink);
    void create_symlink(const path& to, const path& new_symlink,
                                error_code& ec) _NOEXCEPT;

    path current_path();
    path current_path(error_code& ec);
    void current_path(const path& p);
    void current_path(const path& p, error_code& ec) _NOEXCEPT;

    bool exists(file_status s) _NOEXCEPT;
    bool exists(const path& p);
    bool exists(const path& p, error_code& ec) _NOEXCEPT;

    bool equivalent(const path& p1, const path& p2);
    bool equivalent(const path& p1, const path& p2, error_code& ec) _NOEXCEPT;

    uintmax_t    file_size(const path& p);
    uintmax_t    file_size(const path& p, error_code& ec) _NOEXCEPT;

    uintmax_t    hard_link_count(const path& p);
    uintmax_t    hard_link_count(const path& p, error_code& ec) _NOEXCEPT;

    bool is_block_file(file_status s) _NOEXCEPT;
    bool is_block_file(const path& p);
    bool is_block_file(const path& p, error_code& ec) _NOEXCEPT;

    bool is_character_file(file_status s) _NOEXCEPT;
    bool is_character_file(const path& p);
    bool is_character_file(const path& p, error_code& ec) _NOEXCEPT;

    bool is_directory(file_status s) _NOEXCEPT;
    bool is_directory(const path& p);
    bool is_directory(const path& p, error_code& ec) _NOEXCEPT;

    bool is_empty(const path& p);
    bool is_empty(const path& p, error_code& ec) _NOEXCEPT;

    bool is_fifo(file_status s) _NOEXCEPT;
    bool is_fifo(const path& p);
    bool is_fifo(const path& p, error_code& ec) _NOEXCEPT;

    bool is_other(file_status s) _NOEXCEPT;
    bool is_other(const path& p);
    bool is_other(const path& p, error_code& ec) _NOEXCEPT;

    bool is_regular_file(file_status s) _NOEXCEPT; 
    bool is_regular_file(const path& p);
    bool is_regular_file(const path& p, error_code& ec) _NOEXCEPT;

    bool is_socket(file_status s) _NOEXCEPT;
    bool is_socket(const path& p);
    bool is_socket(const path& p, error_code& ec) _NOEXCEPT;

    bool is_symlink(file_status s) _NOEXCEPT;
    bool is_symlink(const path& p);
    bool is_symlink(const path& p, error_code& ec) _NOEXCEPT;

    file_time_type  last_write_time(const path& p);
    file_time_type  last_write_time(const path& p, error_code& ec) _NOEXCEPT;
    void last_write_time(const path& p, file_time_type new_time);
    void last_write_time(const path& p, file_time_type new_time,
                                 error_code& ec) _NOEXCEPT;

    void permissions(const path& p, perms prms);
    void permissions(const path& p, perms prms, error_code& ec) _NOEXCEPT;

    path read_symlink(const path& p);
    path read_symlink(const path& p, error_code& ec);

    bool remove(const path& p);
    bool remove(const path& p, error_code& ec) _NOEXCEPT;

    uintmax_t    remove_all(const path& p);
    uintmax_t    remove_all(const path& p, error_code& ec) _NOEXCEPT;

    void rename(const path& from, const path& to);
    void rename(const path& from, const path& to, error_code& ec) _NOEXCEPT;

    void resize_file(const path& p, uintmax_t size);
    void resize_file(const path& p, uintmax_t size, error_code& ec) _NOEXCEPT;

    space_info   space(const path& p);
    space_info   space(const path& p, error_code& ec) _NOEXCEPT;

    file_status  status(const path& p);
    file_status  status(const path& p, error_code& ec) _NOEXCEPT;

    bool status_known(file_status s) _NOEXCEPT;

    file_status  symlink_status(const path& p);
    file_status  symlink_status(const path& p, error_code& ec) _NOEXCEPT;

    path system_complete(const path& p);
    path system_complete(const path& p, error_code& ec);

    path temp_directory_path();
    path temp_directory_path(error_code& ec);

} } } }  // namespaces std::experimental::filesystem::v1

*/

#include <experimental/__config>
#include <cstddef>
#include <chrono>
#include <iterator>
#include <iosfwd>
#include <locale>
#include <memory>
#include <stack>
#include <string>
#include <system_error>
#include <utility>

#include <__debug>

#include <vector> // TODO: remove this
#include <list> // TODO: remove this

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_FILESYSTEM


typedef chrono::time_point<std::chrono::system_clock>  file_time_type;

struct _LIBCPP_TYPE_VIS space_info
{
  uintmax_t capacity;
  uintmax_t free;
  uintmax_t available;
};

enum class _LIBCPP_TYPE_VIS file_type
{
    none = 0,
    not_found = -1,
    regular = 1,
    directory = 2,
    symlink = 3,
    block = 4,
    character = 5,
    fifo = 6,
    socket = 7,
    unknown = 8
};

enum class _LIBCPP_TYPE_VIS perms
{
    none = 0,

    owner_read   = 0400,
    owner_write  = 0200,
    owner_exec   = 0100,
    owner_all    = 0700,

    group_read   = 040,
    group_write  = 020,
    group_exec   = 010,
    group_all    = 070,

    others_read  = 04,
    others_write = 02,
    others_exec  = 01,
    others_all   = 07,

    all          = 0777,

    set_uid      = 04000,
    set_gid      = 02000,
    sticky_bit   = 01000,
    mask         = 07777,
    unknown      = 0xFFFF,

    add_perms        = 0x10000,
    remove_perms     = 0x20000,
    resolve_symlinks = 0x40000
};

enum class _LIBCPP_TYPE_VIS copy_options
{
    none               = 0,
    skip_existing      = 1,
    overwrite_existing = 2,
    update_existing    = 4,
    recursive          = 8,
    copy_symlinks      = 16,
    skip_symlinks      = 32,
    directories_only   = 64,
    create_symlinks    = 128,
    create_hard_links  = 256
};

enum class directory_options
{
    none = 0,
    follow_directory_symlink = 1,
    skip_permission_denied = 2
};

class _LIBCPP_TYPE_VIS file_status
{
public:
    // constructors
    _LIBCPP_INLINE_VISIBILITY
    explicit file_status(file_type __ft = file_type::none,
                         perms __prms = perms::unknown) _NOEXCEPT
      : __ft_(__ft), __prms_(__prms)
    {}

    file_status(const file_status&) _NOEXCEPT = default;
    file_status(file_status&&) _NOEXCEPT = default;

    _LIBCPP_INLINE_VISIBILITY
    ~file_status() {}

    file_status& operator=(const file_status&) _NOEXCEPT = default;
    file_status& operator=(file_status&&) _NOEXCEPT = default;

    // observers
    _LIBCPP_ALWAYS_INLINE
    file_type type() const _NOEXCEPT {
        return __ft_;
    }

    _LIBCPP_ALWAYS_INLINE
    perms permissions() const _NOEXCEPT {
        return __prms_;
    }

    // modifiers
    _LIBCPP_ALWAYS_INLINE
    void type(file_type __ft) _NOEXCEPT {
        __ft_ = __ft;
    }

    _LIBCPP_ALWAYS_INLINE
    void permissions(perms __p) _NOEXCEPT {
        __prms_ = __p;
    }
private:
    file_type __ft_;
    perms __prms_;
};

class _LIBCPP_TYPE_VIS directory_entry;

template <class _Tp>
struct __is_pathable_imp : public false_type {};

template <>
struct __is_pathable_imp<char*> : public true_type {};

template <>
struct __is_pathable_imp<const char*> : public true_type { };

template <>
struct __is_pathable_imp<string> : public true_type { };

template <>
struct __is_pathable_imp<vector<char>> : public true_type { };

template <>
struct __is_pathable_imp<list<char>> : public true_type { };

template <>
struct __is_pathable_imp<directory_entry> : public true_type { };

template <class _Tp>
struct __is_pathable : public __is_pathable_imp<typename decay<_Tp>::type>::type {};

template <typename _Ret>
_LIBCPP_INLINE_VISIBILITY
_Ret __pathable_convert(const string&);

template <>
_LIBCPP_INLINE_VISIBILITY
inline string
__pathable_convert(const string& __s)
{ return __s; }

template <typename _Ret>
_LIBCPP_INLINE_VISIBILITY
_Ret __pathable_dispatch(const char* __from)
{
    return {string{__from}};
}

template <typename _Ret>
_LIBCPP_INLINE_VISIBILITY
_Ret __pathable_dispatch(const string& __from)
{
    return {__from};
}

template <typename _Ret>
_LIBCPP_INLINE_VISIBILITY
_Ret __pathable_dispatch(const vector<char>& __from)
{
    return {string{__from.begin(), __from.end()}};
}

template <typename _Ret>
_LIBCPP_INLINE_VISIBILITY
_Ret __pathable_dispatch(const list<char>& __from)
{
    return {__from.begin(), __from.end()};
}

template <typename _Ret>
_LIBCPP_INLINE_VISIBILITY
_Ret __pathable_dispatch(const directory_entry & __from)
{
    return __pathable_dispatch<_Ret>(__pathable_dispatch<string>(__from));
}

template <> string
_LIBCPP_INLINE_VISIBILITY
__pathable_dispatch(const directory_entry & __from);

class _LIBCPP_TYPE_VIS path
{
public:
    typedef char value_type;
    typedef basic_string<value_type> string_type;
    static _LIBCPP_CONSTEXPR value_type preferred_separator = '/';
    static _LIBCPP_CONSTEXPR value_type __other_separator = '\\';

    // constructors and destructor
    _LIBCPP_INLINE_VISIBILITY
    path() _NOEXCEPT {}

    _LIBCPP_INLINE_VISIBILITY
    path(const path& __p) : __pn_(__p.__pn_) {}

    _LIBCPP_INLINE_VISIBILITY
    path(path&& __p) _NOEXCEPT : __pn_(_VSTD::move(__p.__pn_)) {}

    template <
        class _Source,
        class = typename enable_if<
                    __is_pathable<_Source>::value
                >::type
        >
    path(const _Source& __src)
        : __pn_(__pathable_dispatch<string_type>(__src))
    {}

    template <class _InputIt>
    path(_InputIt __first, _InputIt __last)
    {
        typedef typename iterator_traits<_InputIt>::value_type _ItVal;
        if (__first != __last) {
            basic_string<_ItVal> __s(__first, __last);
            __pn_ = __pathable_convert<string_type>(__s);
        }
    }

    // TODO
    template <class _Source>
        path(const _Source& __src, const locale& __loc);
    template <class _InputIt>
        path(_InputIt __first, _InputIt _last, const locale& __loc);

    _LIBCPP_INLINE_VISIBILITY
    ~path() {}

    // assignments
    _LIBCPP_INLINE_VISIBILITY
    path& operator=(const path& __p) {
        __pn_ = __p.__pn_;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator=(path&& __p) _NOEXCEPT {
        __pn_ = _VSTD::move(__p.__pn_);
        return *this;
    }

    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    operator=(const _Source& __src)
    {
        return this->assign(__src);
    }


    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    assign(const _Source& __src)
    {
        __pn_ = __pathable_dispatch<string_type>(__src);
        return *this;
    }

    template <class _InputIt>
    path& assign(_InputIt __first, _InputIt __last)
    {
        typedef typename iterator_traits<_InputIt>::value_type _ItVal;
        if (__first != __last) {
            basic_string<_ItVal> __s(__first, __last);
            __pn_ = __pathable_convert<string_type>(__s);
        }
        return *this;
    }

    // appends
    path& operator/=(const path& __p)
    {
        bool const __append_sep =
            ! empty() && not __p.empty()
                && __p.__pn_[0] != preferred_separator
                && __p.__pn_[0] != __other_separator
                && __pn_.back() != preferred_separator
                && __pn_.back() != __other_separator;
        if (__append_sep) __pn_ += preferred_separator;
        __pn_ += __p.native();
        return *this;
    }

    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    operator/=(const _Source& __src)
    {
        path __p(__pathable_dispatch<string_type>(__src));
        return this->operator/=(__p);
    }

    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    append(const _Source& __src)
    {
        path __p(__pathable_dispatch<string_type>(__src));
        return this->operator/=(__p);
    }

    template <class _InputIt>
    path& append(_InputIt __first, _InputIt __last)
    {
        typedef typename iterator_traits<_InputIt>::value_type _ItVal;
        if (__first != __last) {
            basic_string<_ItVal> __s(__first, __last);
            path __p = __pathable_convert<string_type>(__s);
            this->operator/=(__p);
        }
        return *this;
    }

    // concatenation
    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(const path& __x) {
        __pn_ += __x.__pn_;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(const string_type& __x) {
        __pn_ += __x;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(const value_type* __x) {
        __pn_ += __x;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    path& operator+=(value_type __x) {
        __pn_ += __x;
        return *this;
    }

    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    operator+=(const _Source& __x)
    {
        return this->operator+=(__pathable_dispatch<string_type>(__x));
    }

    template <class _EcharT>
    typename enable_if<__is_pathable<basic_string<_EcharT>>::value, path&>::type
    operator+=(_EcharT __x)
    {
        basic_string<_EcharT> __tmp;
        __tmp += __x;
        return this->operator+=(__pathable_convert<string_type>(__tmp));
    }

    template <class _Source>
    typename enable_if<__is_pathable<_Source>::value, path&>::type
    concat(const _Source& __x)
    {
        return this->operator+=(__x);
    }

    template <class _InputIt>
    path& concat(_InputIt __first, _InputIt __last)
    {
        typedef typename iterator_traits<_InputIt>::value_type _ItVal;
        if (__first != __last) {
            basic_string<_ItVal> __s(__first, __last);
            path __p = __pathable_convert<string_type>(__s);
            this->operator+=(__p);
        }
        return *this;
    }

    // modifiers
    _LIBCPP_INLINE_VISIBILITY
    void  clear() _NOEXCEPT {
        __pn_.clear();
    }

    path& make_preferred();

    path& remove_filename() {
        return *this = parent_path();
    }

    path& replace_filename(const path& __replacement) {
        remove_filename();
        return (*this /= __replacement);
    }

    path& replace_extension(const path& __replacement = path());

    _LIBCPP_INLINE_VISIBILITY
    void  swap(path& __rhs) _NOEXCEPT {
        __pn_.swap(__rhs.__pn_);
    }

    // native format observers
    _LIBCPP_INLINE_VISIBILITY
    const string_type& native() const _NOEXCEPT {
        return __pn_;
    }

    _LIBCPP_INLINE_VISIBILITY
    const value_type*   c_str() const _NOEXCEPT {
        return __pn_.c_str();
    }

    _LIBCPP_INLINE_VISIBILITY
    operator string_type() const {
        return __pn_;
    }

    // TODO
    template <class _EcharT, class _Traits = char_traits<_EcharT>,
              class _Allocator = allocator<_EcharT> >
    basic_string<_EcharT, _Traits, _Allocator>
    string(const _Allocator& __a = _Allocator()) const;

    _LIBCPP_INLINE_VISIBILITY
    std::string string() const {
        return __pn_;
    }

    std::wstring wstring() const; // TODO
    std::string  u8string() const; // TODO
    std::u16string u16string() const; // TODO
    std::u32string u32string() const; // TODO

    // generic format observers
    template <class _EcharT, class _Traits = char_traits<_EcharT>,
              class _Allocator = allocator<_EcharT> >
    basic_string<_EcharT, _Traits, _Allocator>
    generic_string(const _Allocator& __a = _Allocator()) const; // TODO
    std::string    generic_string() const; // TODO
    std::wstring   generic_wstring() const; // TODO
    std::string    generic_u8string() const; // TODO
    std::u16string generic_u16string() const; // TODO
    std::u32string generic_u32string() const; // TODO

    // compare
    _LIBCPP_INLINE_VISIBILITY
    int compare(const path& __p) const _NOEXCEPT {
        return __pn_.compare(__p.__pn_);
    }

    _LIBCPP_INLINE_VISIBILITY
    int compare(const string_type& __s) const {
        return __pn_.compare(__s);
    }

    _LIBCPP_INLINE_VISIBILITY
    int compare(const value_type* __s) const {
        return __pn_.compare(__s);
    }

    // decomposition
    path root_name() const;
    path root_directory() const;
    path root_path() const;
    path relative_path() const;
    path parent_path() const;
    path filename() const;
    path stem() const;
    path extension() const;

    // query
    _LIBCPP_INLINE_VISIBILITY
    bool empty() const _NOEXCEPT {
        return __pn_.empty();
    }

    bool has_root_name() const
    { return !root_name().empty(); }

    bool has_root_directory() const
    { return !root_directory().empty(); }

    bool has_root_path() const
    { return !root_path().empty(); }

    bool has_relative_path() const
    { return !relative_path().empty(); }

    bool has_parent_path() const
    { return !parent_path().empty(); }

    bool has_filename() const
    { return !filename().empty(); }

    bool has_stem() const
    { return !stem().empty(); }

    bool has_extension() const
    { return !extension().empty(); }

    bool is_absolute() const
    { return has_root_directory(); }

    bool is_relative() const
    { return !is_absolute(); }

    // iterators
    class iterator;
    typedef iterator const_iterator;

    iterator begin() const;
    iterator end() const;

private:
    string_type __pn_;
};


inline _LIBCPP_ALWAYS_INLINE
void swap(path& __lhs, path& __rhs) _NOEXCEPT
{
    __lhs.swap(__rhs);
}

inline _LIBCPP_INLINE_VISIBILITY
size_t hash_value(const path& __p) _NOEXCEPT
{
    hash<path::string_type> __h;
    return __h(__p.native());
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator==(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) == 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) != 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator<(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) < 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator<=(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) <= 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator>(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) > 0;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator>=(const path& __lhs, const path& __rhs) _NOEXCEPT
{
    return __lhs.compare(__rhs) >= 0;
}

inline _LIBCPP_INLINE_VISIBILITY
path operator/(const path& __lhs, const path& __rhs)
{
    return path(__lhs) /= __rhs;
}

template <class _CharT, class _Traits>
_LIBCPP_INLINE_VISIBILITY
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p)
{
    __os << __p.native();
    return __os;
}

template <class _CharT, class _Traits>
_LIBCPP_INLINE_VISIBILITY
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, path& __p)
{
    path::string_type __tmp;
    __is >> __tmp;
    __p = __tmp;
    return __is;
}

template <class _Source>
path u8path(const _Source&); // TODO

template <class _InputIt>
path u8path(_InputIt, _InputIt); // TODO


class _LIBCPP_TYPE_VIS path::iterator
    : public _VSTD::iterator<bidirectional_iterator_tag, path>
{
public:
    _LIBCPP_INLINE_VISIBILITY
    iterator() : __elem_(), __path_ptr_(nullptr), __pos_(0) {}

    iterator(const iterator&) = default;
    iterator(iterator&&) = default;
    ~iterator() = default;

    iterator& operator=(const iterator&) = default;
    iterator& operator=(iterator&&) = default;

    _LIBCPP_INLINE_VISIBILITY
    const path& operator*() const {
        return __elem_;
    }

    _LIBCPP_INLINE_VISIBILITY
    const path& operator->() const {
        return __elem_;
    }

    _LIBCPP_INLINE_VISIBILITY
    iterator& operator++() {
        return __increment();
    }

    _LIBCPP_INLINE_VISIBILITY
    iterator operator++(int) {
        iterator __it(*this);
        this->operator++();
        return __it;
    }

    _LIBCPP_INLINE_VISIBILITY
    iterator& operator--() {
        return __decrement();
    }

    _LIBCPP_INLINE_VISIBILITY
    iterator operator--(int) {
        iterator __it(*this);
        this->operator--();
        return __it;
    }
private:
    _LIBCPP_FUNC_VIS
    iterator& __increment();

    _LIBCPP_FUNC_VIS
    iterator& __decrement();

    _LIBCPP_FUNC_VIS
    bool __set_position(size_t);

    _LIBCPP_FUNC_VIS
    bool __valid_iterator_position() const;
private:
    friend class path;
    friend bool operator==(const iterator&, const iterator&);

    path __elem_;
    const path* __path_ptr_;
    size_t __pos_;
};

inline _LIBCPP_INLINE_VISIBILITY
bool operator==(const path::iterator& __lhs, const path::iterator& __rhs)
{
    return __lhs.__path_ptr_ == __rhs.__path_ptr_ &&
           __lhs.__pos_ == __rhs.__pos_;
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(const path::iterator& __lhs, const path::iterator& __rhs)
{
    return !(__lhs == __rhs);
}


class _LIBCPP_EXCEPTION_ABI filesystem_error : public system_error
{
public:
    _LIBCPP_INLINE_VISIBILITY
    filesystem_error(const string& __what, error_code __ec)
        : system_error(__ec, __what),
          __paths_(make_shared<_Storage>(path(), path()))
    {}

    _LIBCPP_INLINE_VISIBILITY
    filesystem_error(const string& __what, const path& __p1, error_code __ec)
        : system_error(__ec, __what),
        __paths_(make_shared<_Storage>(__p1, path()))
    {}

    _LIBCPP_INLINE_VISIBILITY
    filesystem_error(const string& __what, const path& __p1, const path& __p2,
                     error_code __ec)
        : system_error(__ec, __what),
          __paths_(make_shared<_Storage>(__p1, __p2))
    {}

    _LIBCPP_INLINE_VISIBILITY
    const path& path1() const _NOEXCEPT {
        return __paths_->first;
    }

    _LIBCPP_INLINE_VISIBILITY
    const path& path2() const _NOEXCEPT {
        return __paths_->second;
    }

    // TODO(ericwf): Create a custom error message.
    //const char* what() const _NOEXCEPT;

private:
    typedef pair<path, path> _Storage;
    shared_ptr<_Storage> __paths_;
};

// operational functions

path absolute(const path&);
path absolute(const path&, const path&);

path canonical(const path&);
path canonical(const path&, const path&);
path canonical(const path&, error_code&);
path canonical(const path&, const path&, error_code&);

void copy(const path&, const path&);
void copy(const path&, const path&, error_code&) _NOEXCEPT;
void copy(const path&, const path&, copy_options);
void copy(const path&, const path&, copy_options, error_code&) _NOEXCEPT;

bool copy_file(const path&, const path&);
bool copy_file(const path&, const path&, error_code&) _NOEXCEPT;
bool copy_file(const path&, const path&, copy_options);
bool copy_file(const path&, const path&, copy_options, error_code&) _NOEXCEPT;

void copy_symlink(const path&, const path&);
void copy_symlink(const path&, const path&, error_code&) _NOEXCEPT;

bool create_directories(const path&);
bool create_directories(const path&, error_code&) _NOEXCEPT;

bool create_directory(const path&);
bool create_directory(const path&, error_code&) _NOEXCEPT;

bool create_directory(const path&, const path&);
bool create_directory(const path&, const path&, error_code&) _NOEXCEPT;

void create_directory_symlink(const path&, const path&);
void create_directory_symlink(const path&, const path&, error_code&) _NOEXCEPT;

void create_hard_link(const path&, const path&);
void create_hard_link(const path&, const path&, error_code&) _NOEXCEPT;

void create_symlink(const path&, const path&);
void create_symlink(const path&, const path&, error_code&) _NOEXCEPT;

path current_path();
path current_path(error_code&);
void current_path(const path&);
void current_path(const path&, error_code&) _NOEXCEPT;

bool exists(file_status) _NOEXCEPT;
bool exists(const path&);
bool exists(const path&, error_code&) _NOEXCEPT;

bool equivalent(const path&, const path&);
bool equivalent(const path&, const path&, error_code&) _NOEXCEPT;

uintmax_t file_size(const path&);
uintmax_t file_size(const path&, error_code&) _NOEXCEPT;

uintmax_t hard_link_count(const path&);
uintmax_t hard_link_count(const path&, error_code&) _NOEXCEPT;

bool is_block_file(file_status) _NOEXCEPT;
bool is_block_file(const path&);
bool is_block_file(const path&, error_code&) _NOEXCEPT;

bool is_character_file(file_status) _NOEXCEPT;
bool is_character_file(const path&);
bool is_character_file(const path&, error_code&) _NOEXCEPT;

bool is_directory(file_status) _NOEXCEPT;
bool is_directory(const path&);
bool is_directory(const path&, error_code&) _NOEXCEPT;

bool is_empty(const path&);
bool is_empty(const path&, error_code&) _NOEXCEPT;

bool is_fifo(file_status) _NOEXCEPT;
bool is_fifo(const path&);
bool is_fifo(const path&, error_code&) _NOEXCEPT;

bool is_other(file_status) _NOEXCEPT;
bool is_other(const path&);
bool is_other(const path&, error_code&) _NOEXCEPT;

bool is_regular_file(file_status) _NOEXCEPT;
bool is_regular_file(const path&);
bool is_regular_file(const path&, error_code&) _NOEXCEPT;

bool is_socket(file_status) _NOEXCEPT;
bool is_socket(const path&);
bool is_socket(const path&, error_code&) _NOEXCEPT;

bool is_symlink(file_status) _NOEXCEPT;
bool is_symlink(const path&);
bool is_symlink(const path&, error_code&) _NOEXCEPT;

file_time_type last_write_time(const path&);
file_time_type last_write_time(const path&, error_code&) _NOEXCEPT;
void last_write_time(const path&, file_time_type);
void last_write_time(const path&, file_time_type, error_code&) _NOEXCEPT;

void permissions(const path&, perms);
void permissions(const path&, perms, error_code&) _NOEXCEPT;

path read_symlink(const path&);
path read_symlink(const path&, error_code&);

bool remove(const path&);
bool remove(const path&, error_code&) _NOEXCEPT;

uintmax_t remove_all(const path&);
uintmax_t remove_all(const path&, error_code&) _NOEXCEPT;

void rename(const path&, const path&);
void rename(const path&, const path&, error_code&) _NOEXCEPT;

void resize_file(const path&, uintmax_t);
void resize_file(const path&, uintmax_t, error_code&) _NOEXCEPT;

space_info space(const path&);
space_info space(const path&, error_code&) _NOEXCEPT;

file_status status(const path&);
file_status status(const path&, error_code&) _NOEXCEPT;

bool status_known(file_status) _NOEXCEPT;

file_status symlink_status(const path&);
file_status symlink_status(const path&, error_code&) _NOEXCEPT;

path system_complete(const path&);
path system_complete(const path&, error_code&);

path temp_directory_path();
path temp_directory_path(error_code&);


class directory_entry
{
private:
    typedef _VSTD_FS::path _Path;

public:
    // constructors and destructors
    directory_entry() _NOEXCEPT = default;
    directory_entry(directory_entry const&) = default;
    directory_entry(directory_entry&&) _NOEXCEPT = default;

    _LIBCPP_INLINE_VISIBILITY
    directory_entry(_Path const& __p) : __p_(__p) {}

    ~directory_entry() {}

    directory_entry& operator=(directory_entry const&) = default;
    directory_entry& operator=(directory_entry&&) _NOEXCEPT = default;

    _LIBCPP_INLINE_VISIBILITY
    void assign(_Path const& __p) {
        __p_ = __p;
    }

    _LIBCPP_INLINE_VISIBILITY
    void replace_filename(_Path const& __p) {
        __p_ = __p_.parent_path() / __p;
    }

    _LIBCPP_INLINE_VISIBILITY
    _Path const& path() const _NOEXCEPT {
        return __p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    operator const _Path&() const _NOEXCEPT {
        return __p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    file_status status() const {
        return _VSTD_FS::status(__p_);
    }

    _LIBCPP_INLINE_VISIBILITY
    file_status status(error_code& __ec) const _NOEXCEPT {
        return _VSTD_FS::status(__p_, __ec);
    }

    _LIBCPP_INLINE_VISIBILITY
    file_status symlink_status() const {
        return _VSTD_FS::symlink_status(__p_);
    }

    _LIBCPP_INLINE_VISIBILITY
    file_status symlink_status(error_code& __ec) const _NOEXCEPT {
        return _VSTD_FS::symlink_status(__p_, __ec);
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator< (directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ < __rhs.__p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator==(directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ == __rhs.__p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator!=(directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ != __rhs.__p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator<=(directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ <= __rhs.__p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator> (directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ > __rhs.__p_;
    }

    _LIBCPP_INLINE_VISIBILITY
    bool operator>=(directory_entry const& __rhs) const _NOEXCEPT {
        return __p_ >= __rhs.__p_;
    }
private:
    _Path __p_;
};


class directory_iterator;
class recursive_directory_iterator;
class __dir_stream;

class directory_iterator
{
public:
    typedef directory_entry value_type;
    typedef ptrdiff_t difference_type;
    typedef value_type const* pointer;
    typedef value_type const& reference;
    typedef input_iterator_tag iterator_category;

public:
    //ctor & dtor
    directory_iterator() _NOEXCEPT
    { }

    explicit directory_iterator(const path& __p)
        : directory_iterator(__p, nullptr)
    { }

    directory_iterator(const path& __p, error_code& __ec) _NOEXCEPT
        : directory_iterator(__p, &__ec)
    { }

    directory_iterator(const directory_iterator&) = default;
    directory_iterator(directory_iterator&&) = default;
    directory_iterator& operator=(const directory_iterator&) = default;
    directory_iterator& operator=(directory_iterator&&) = default;
    ~directory_iterator() = default;

    const directory_entry& operator*() const
    { return __elem_; }

    const directory_entry* operator->() const
    { return &__elem_; }

    directory_iterator& operator++()
    { return __increment(); }

    directory_iterator operator++(int)
    {
        directory_iterator __it(*this);
        __increment();
        return __it;
    }

    directory_iterator& increment(error_code& __ec) _NOEXCEPT
    { return __increment(&__ec); }

    bool operator==(const directory_iterator& __rhs) const _NOEXCEPT
    { return __stream_.get() == __rhs.__stream_.get(); }

    bool operator!=(const directory_iterator& __rhs) const _NOEXCEPT
    { return !(*this == __rhs); }

private:
    // recursive_directory_iterator uses this class
    // as its underlying implementation, and therefore it
    // needs access to the methods that take an optional error_code
    friend class recursive_directory_iterator;

    // construct the dir_stream
    directory_iterator(const path&, error_code *);
    directory_iterator& __increment(error_code * __ec = nullptr);
    // convert iterator into end iterator
    void __make_end();

private:
    shared_ptr<__dir_stream> __stream_;
    path __root_path_;
    directory_entry __elem_;
};

// enable directory_iterator range-based for statements
inline _LIBCPP_INLINE_VISIBILITY
directory_iterator begin(directory_iterator __iter) _NOEXCEPT
{
    return __iter;
}

inline _LIBCPP_INLINE_VISIBILITY
directory_iterator end(const directory_iterator&) _NOEXCEPT
{
    return directory_iterator();
}

class recursive_directory_iterator
    {
    public:
        using value_type = directory_entry;
        using difference_type = std::ptrdiff_t;
        using pointer = directory_entry const *;
        using reference = directory_entry const &;
        using iterator_category = std::input_iterator_tag;

    public:
        // constructors and destructor
        recursive_directory_iterator() _NOEXCEPT
        {}

        explicit recursive_directory_iterator(const path& p,
                    directory_options xoptions = directory_options::none)
            : recursive_directory_iterator(p, xoptions,  nullptr)
        { }

        recursive_directory_iterator(const path& p,
            directory_options xoptions, std::error_code& ec) _NOEXCEPT
            : recursive_directory_iterator(p, xoptions, &ec)
        { }

        recursive_directory_iterator(const path& p, std::error_code& ec) _NOEXCEPT
            : recursive_directory_iterator(p, directory_options::none,  &ec)
        { }

        recursive_directory_iterator(const recursive_directory_iterator&) = default;
        recursive_directory_iterator(recursive_directory_iterator&&) = default;

        recursive_directory_iterator & 
        operator=(const recursive_directory_iterator&) = default;

        recursive_directory_iterator & 
        operator=(recursive_directory_iterator&&) = default;

        ~recursive_directory_iterator() = default;

        ////////////////////////////////////////////////////////////////////////
        //
        const directory_entry& operator*() const
        { return __entry_; }

        const directory_entry* operator->() const
        { return &__entry_; }

        ////////////////////////////////////////////////////////////////////////
        recursive_directory_iterator& operator++()
        { return __increment(); }

        recursive_directory_iterator operator++(int)
        {
            auto cp = *this;
            __increment();
            return cp;
        }
        
        recursive_directory_iterator& increment(std::error_code& ec)
        { return __increment(&ec); }

        ////////////////////////////////////////////////////////////////////////
        directory_options options() const _NOEXCEPT
        { return __options_; }
        
        ////////////////////////////////////////////////////////////////////////
        int depth() const
        {
            // __stack_ptr_ && __stack_ptr_->size() == 0 should
            // never be true
            return (__stack_ptr_ ? static_cast<int>(__stack_ptr_->size() - 1) : 0); 
        }
        
        ////////////////////////////////////////////////////////////////////////
        bool recursion_pending() const _NOEXCEPT
        { return __rec_; }
           
        ////////////////////////////////////////////////////////////////////////
        void pop()
        {
            if (!__stack_ptr_) return;
            _LIBCPP_ASSERT(__stack_ptr_->size() > 0, "Popping an empty stack");
            __stack_ptr_->top() = directory_iterator();
            __increment();
        }
        
        ////////////////////////////////////////////////////////////////////////
        void disable_recursion_pending() _NOEXCEPT
        { __rec_ = false; }
        
        ////////////////////////////////////////////////////////////////////////
        bool operator==(const recursive_directory_iterator& other) const _NOEXCEPT
        { return __stack_ptr_ == other.__stack_ptr_; }
        
        ////////////////////////////////////////////////////////////////////////
        bool operator!=(const recursive_directory_iterator& other) const _NOEXCEPT
        { return !(*this == other);}
    
    private:
        recursive_directory_iterator(const path& __p, directory_options __opt,
                                     error_code *__ec);

        void __make_end();
        bool ___try_recursion(error_code *ec);
        recursive_directory_iterator& __increment(error_code *__ec=nullptr);

        shared_ptr<stack<directory_iterator>> __stack_ptr_{nullptr};
        directory_entry __entry_;
        directory_options __options_{directory_options::none};
        bool __rec_{true};
    };                                     // class recursive_directory_iterator

// enable recursive_directory_iterator range-based for statements
inline _LIBCPP_INLINE_VISIBILITY
recursive_directory_iterator begin(recursive_directory_iterator __iter) _NOEXCEPT
{
    return __iter;
}

inline _LIBCPP_INLINE_VISIBILITY
recursive_directory_iterator end(const recursive_directory_iterator&) _NOEXCEPT
{
    return recursive_directory_iterator();
}


_LIBCPP_END_NAMESPACE_EXPERIMENTAL_FILESYSTEM

#endif // _LIBCPP_EXPERIMENTAL_FILESYSTEM
