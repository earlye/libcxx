// -*- C++ -*-
//===-------------------------- variant -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_VARIANT
#define _LIBCPP_VARIANT

/*
    variant synopsis
namespace std {
  // ?.3, variant of value types
  template <class... Types> class variant;

  // ?.4, variant helper classes
  template <class T> struct variant_size; // undefined
  template <class T> struct variant_size<const T>;
  template <class T> struct variant_size<volatile T>;
  template <class T> struct variant_size<const volatile T>;
  template <class T> constexpr size_t variant_size_v
    = variant_size<T>::value;

  template <class... Types>
    struct variant_size<variant<Types...>>;

  template <size_t I, class T> struct variant_alternative; // undefined
  template <size_t I, class T> struct variant_alternative<I, const T>;
  template <size_t I, class T> struct variant_alternative<I, volatile T>;
  template <size_t I, class T> struct variant_alternative<I, const volatile T>;
  template <size_t I, class T>
    using variant_alternative_t = typename variant_alternative<I, T>::type;

  template <size_t I, class... Types>
    struct variant_alternative<I, variant<Types...>>;

  constexpr size_t variant_npos = -1;


  // ?.5, In-place construction
  template <class T> struct in_place_type_t{ explicit in_place_type_t() = default; };
  template <class T> constexpr in_place_type_t<T> in_place_type{};

  template <size_t I> struct in_place_index_t{ explicit in_place_index_t() = default; };
  template <size_t I> constexpr in_place_index_t<I> in_place_index{};

  // ?.6, Value access
  template <class T, class... Types>
    constexpr bool holds_alternative(const variant<Types...>&) noexcept;

  template <size_t I, class... Types>
    constexpr variant_alternative_t<I, variant<Types...>>&
    get(variant<Types...>&);
  template <size_t I, class... Types>
    constexpr variant_alternative_t<I, variant<Types...>>&&
    get(variant<Types...>&&);
  template <size_t I, class... Types>
    constexpr variant_alternative_t<I, variant<Types...>> const&
    get(const variant<Types...>&);
  template <size_t I, class... Types>
    constexpr variant_alternative_t<I, variant<Types...>> const&&
    get(const variant<Types...>&&);

  template <class T, class... Types>
    constexpr T& get(variant<Types...>&);
  template <class T, class... Types>
    constexpr T&& get(variant<Types...>&&);
  template <class T, class... Types>
    constexpr const T& get(const variant<Types...>&);
  template <class T, class... Types>
    constexpr const T&& get(const variant<Types...>&&);

  template <size_t I, class... Types>
    constexpr add_pointer_t<variant_alternative_t<I, variant<Types...>>>
    get_if(variant<Types...>*) noexcept;
  template <size_t I, class... Types>
    constexpr add_pointer_t<const variant_alternative_t<I, variant<Types...>>>
    get_if(const variant<Types...>*) noexcept;

  template <class T, class... Types>
    constexpr add_pointer_t<T> get_if(variant<Types...>*) noexcept;
  template <class T, class... Types>
    constexpr add_pointer_t<const T> get_if(const variant<Types...>*) noexcept;

  // ?.7, Relational operators
  template <class... Types>
    constexpr bool operator==(const variant<Types...>&,
                              const variant<Types...>&);
  template <class... Types>
    constexpr bool operator!=(const variant<Types...>&,
                              const variant<Types...>&);
  template <class... Types>
    constexpr bool operator<(const variant<Types...>&,
                             const variant<Types...>&);
  template <class... Types>
    constexpr bool operator>(const variant<Types...>&,
                             const variant<Types...>&);
  template <class... Types>
    constexpr bool operator<=(const variant<Types...>&,
                              const variant<Types...>&);
  template <class... Types>
    constexpr bool operator>=(const variant<Types...>&,
                              const variant<Types...>&);

  // ?.8, Visitation
  template <class Visitor, class... Variants>
  constexpr see below visit(Visitor&&, Variants&&...);

  // ?.9, Class monostate
  struct monostate;

  // ?.10, monostate relational operators
  constexpr bool operator<(monostate, monostate) noexcept;
  constexpr bool operator>(monostate, monostate) noexcept;
  constexpr bool operator<=(monostate, monostate) noexcept;
  constexpr bool operator>=(monostate, monostate) noexcept;
  constexpr bool operator==(monostate, monostate) noexcept;
  constexpr bool operator!=(monostate, monostate) noexcept;

  // ?.11, Specialized algorithms
  template <class... Types>
  void swap(variant<Types...>&, variant<Types...>&) noexcept(see below);

  // ?.12, class bad_variant_access
  class bad_variant_access;

  // ?.13, Hash support
  template <class T> struct hash;
  template <class... Types> struct hash<variant<Types...>>;
  template <> struct hash<monostate>;

  // ?.14, Allocator-related traits
  template <class T, class Alloc> struct uses_allocator;
  template <class... Types, class Alloc>
  struct uses_allocator<variant<Types...>, Alloc>;
  
} // namespace std

*/

#include <__config>
#include <tuple>
#include <functional>
#include <type_traits>
#include <initializer_list>
#include <__debug>


#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif


namespace std { // explicitly not using versioning namespace

class _LIBCPP_EXCEPTION_ABI bad_variant_access : public exception{
public:
   bad_variant_access() noexcept : exception() {}
   _LIBCPP_FUNC_VIS const char* what() const noexcept;
};

} // end namespace std

#if _LIBCPP_STD_VER > 14

_LIBCPP_BEGIN_NAMESPACE_STD

template <class... _Types> class variant;

  // ?.4, variant helper classes
template <class _Tp> struct variant_size; // undefined
template <class _Tp> struct variant_size<const _Tp> : variant_size<_Tp> {};
template <class _Tp> struct variant_size<volatile _Tp> : variant_size<_Tp> {};
template <class _Tp> struct variant_size<const volatile _Tp> : variant_size<_Tp> {};
template <class _Tp> constexpr size_t variant_size_v
    = variant_size<_Tp>::value;

template <class... _Types>
struct variant_size<variant<_Types...>>
    : integral_constant<size_t, sizeof...(_Types)> {};

template <size_t _Idx, class _Tp> struct variant_alternative; // undefined
template <size_t _Idx, class _Tp> struct variant_alternative<_Idx, const _Tp> {
    using type = typename variant_alternative<_Idx, _Tp>::type const;
};
template <size_t _Idx, class _Tp> struct variant_alternative<_Idx, volatile _Tp> {
  using type = typename variant_alternative<_Idx, _Tp>::type volatile;
};
template <size_t _Idx, class _Tp> struct variant_alternative<_Idx, const volatile _Tp> {
  using type = typename variant_alternative<_Idx, _Tp>::type const volatile;
};
template <size_t _Idx, class _Tp>
using variant_alternative_t = typename variant_alternative<_Idx, _Tp>::type;

template <size_t _Idx, class... _Types>
struct variant_alternative<_Idx, variant<_Types...>> {
  static_assert(_Idx < sizeof...(_Types), "Index is out of range");
  using type = typename tuple_element<_Idx, __tuple_types<_Types...>>::type;
};

constexpr size_t variant_npos = -1;

template <class>
struct _LIBCPP_TYPE_VIS_ONLY in_place_type_t {
    explicit in_place_type_t() = default;
};

template <class _Tp>
constexpr in_place_type_t<_Tp> in_place_type{};

template <size_t>
struct _LIBCPP_TYPE_VIS_ONLY in_place_index_t {
    explicit in_place_index_t() = default;
};

template <size_t _Idx>
constexpr in_place_index_t<_Idx> in_place_index{};

template <class _Tp, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr bool holds_alternative(const variant<_Types...>& __v) noexcept {
    using _Found = __find_exactly_one_t<_Tp, _Types...>;
    return __v.index() == _Found::value;
};

template <size_t _Idx, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr variant_alternative_t<_Idx, variant<_Types...>>&
get(variant<_Types...>& __v) {
    if (__v.index() != _Idx) __libcpp_throw(bad_variant_access());
    return __v.__base_.__imp_.__get(in_place_index<_Idx>);
}

template <size_t _Idx, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr variant_alternative_t<_Idx, variant<_Types...>>&&
get(variant<_Types...>&& __v) {
    using _Tp = variant_alternative_t<_Idx, variant<_Types...>>;
    if (__v.index() != _Idx) __libcpp_throw(bad_variant_access());
    return static_cast<_Tp&&>(__v.__base_.__imp_.__get(in_place_index<_Idx>));
}

template <size_t _Idx, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr variant_alternative_t<_Idx, variant<_Types...>> const&
get(const variant<_Types...>& __v) {
    if (__v.index() != _Idx) __libcpp_throw(bad_variant_access());
    return __v.__base_.__imp_.__get(in_place_index<_Idx>);
}

template <size_t _Idx, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr variant_alternative_t<_Idx, variant<_Types...>> const&&
get(const variant<_Types...>&& __v) {
    using _Tp = variant_alternative_t<_Idx, variant<_Types...>>;
    if (__v.index() != _Idx) __libcpp_throw(bad_variant_access());
    return static_cast<_Tp const&&>(__v.__base_.__imp_.__get(in_place_index<_Idx>));
}

template <class _Tp, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr _Tp& get(variant<_Types...>& __v) {
    return _VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Tp, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr _Tp&& get(variant<_Types...>&& __v) {
    return _VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(_VSTD::move(__v));
}

template <class _Tp, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr const _Tp& get(const variant<_Types...>& __v) {
    return _VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Tp, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr const _Tp&& get(const variant<_Types...>&& __v) {
    return _VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(_VSTD::move(__v));
}

template <size_t _Idx, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr add_pointer_t<variant_alternative_t<_Idx, variant<_Types...>>>
get_if(variant<_Types...>* __v) noexcept {
    return __v && __v->index() == _Idx
        ? _VSTD::addressof(_VSTD::get<_Idx>(*__v))
        : nullptr;
}

template <size_t _Idx, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr add_pointer_t<const variant_alternative_t<_Idx, variant<_Types...>>>
get_if(const variant<_Types...>* __v) noexcept {
    return __v && __v->index() == _Idx
        ? _VSTD::addressof(_VSTD::get<_Idx>(*__v))
        : nullptr;
}

template <class _Tp, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr add_pointer_t<_Tp> get_if(variant<_Types...>* __v) noexcept {
    using _Found = __find_exactly_one_t<_Tp, _Types...>;
    return __v && __v->index() == _Found::value
        ? _VSTD::addressof(_VSTD::get<_Found::value>(*__v))
        : nullptr;
}

template <class _Tp, class... _Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr add_pointer_t<const _Tp> get_if(const variant<_Types...>* __v) noexcept {
    using _Found = __find_exactly_one_t<_Tp, _Types...>;
    return __v && __v->index() == _Found::value
        ? _VSTD::addressof(_VSTD::get<_Found::value>(*__v))
        : nullptr;
}

template <class... _Types, class _Alloc>
struct _LIBCPP_TYPE_VIS_ONLY uses_allocator<variant<_Types...>, _Alloc> : true_type {};

namespace __variant_detail {

template <bool _CanCopy, bool _CanMove, bool _CanCopyAssign, bool _CanMoveAssign>
struct __variant_sfinae_base;

template <>
struct __variant_sfinae_base<true, true, true, true> {
  static constexpr bool __copy = true;
  static constexpr bool __move = true;
  __variant_sfinae_base() = default;
  __variant_sfinae_base(__variant_sfinae_base const&) = default;
  __variant_sfinae_base(__variant_sfinae_base &&) = default;
  __variant_sfinae_base& operator=(__variant_sfinae_base const&) = default;
  __variant_sfinae_base& operator=(__variant_sfinae_base &&) = default;
};

template <>
struct __variant_sfinae_base<true, true, false, false> {
  static constexpr bool __copy = true;
  static constexpr bool __move = true;
  __variant_sfinae_base() = default;
  __variant_sfinae_base(__variant_sfinae_base const&) = default;
  __variant_sfinae_base(__variant_sfinae_base &&) = default;
  __variant_sfinae_base& operator=(__variant_sfinae_base const&) = delete;
  __variant_sfinae_base& operator=(__variant_sfinae_base &&) = delete;
};


template <bool _CanCA, bool _CanMA>
struct __variant_sfinae_base<true, false, _CanCA, _CanMA> {
  static constexpr bool __copy = true;
  static constexpr bool __move = true;
  __variant_sfinae_base() = default;
  __variant_sfinae_base(__variant_sfinae_base const&) = default;
  __variant_sfinae_base(__variant_sfinae_base &&) = delete;
  __variant_sfinae_base& operator=(__variant_sfinae_base const&) = delete;
  __variant_sfinae_base& operator=(__variant_sfinae_base &&) = delete;
};

template <bool _CanCA>
struct __variant_sfinae_base<false, true, _CanCA, true> {
  static constexpr bool __copy = false;
  static constexpr bool __move = true;
  __variant_sfinae_base() = default;
  __variant_sfinae_base(__variant_sfinae_base const&) = delete;
  __variant_sfinae_base(__variant_sfinae_base &&) = default;
  __variant_sfinae_base& operator=(__variant_sfinae_base const&) = delete;
  __variant_sfinae_base& operator=(__variant_sfinae_base&&) = default;
};

template <bool _CanCA>
struct __variant_sfinae_base<false, true, _CanCA, false> {
  static constexpr bool __copy = false;
  static constexpr bool __move = true;
  __variant_sfinae_base() = default;
  __variant_sfinae_base(__variant_sfinae_base const&) = delete;
  __variant_sfinae_base(__variant_sfinae_base &&) = default;
  __variant_sfinae_base& operator=(__variant_sfinae_base const&) = delete;
  __variant_sfinae_base& operator=(__variant_sfinae_base&&) = delete;
};

template <bool _CanCA, bool _CanMA>
struct __variant_sfinae_base<false, false, _CanCA, _CanMA> {
  static constexpr bool __copy = false;
  static constexpr bool __move = false;
  __variant_sfinae_base() = default;
  __variant_sfinae_base(__variant_sfinae_base const&) = delete;
  __variant_sfinae_base(__variant_sfinae_base &&) = delete;
  __variant_sfinae_base& operator=(__variant_sfinae_base const&) = delete;
  __variant_sfinae_base& operator=(__variant_sfinae_base&&) = delete;
};

template <class ..._Types>
using __variant_sfinae_base_t =
    __variant_sfinae_base<
        __all<is_copy_constructible<_Types>::value...>::value,
        __all<is_move_constructible<_Types>::value...>::value,
        __all<is_copy_assignable<_Types>::value...>::value,
        __all<is_move_assignable<_Types>::value...>::value
    >;

template <size_t _Idx, class _PossibleTp>
struct _CheckCtorImp {
  static constexpr in_place_index_t<_Idx> __ip{};
  static constexpr size_t __index = _Idx;
  using type =  typename _PossibleTp::type;
  template <class ..._Args>
  static constexpr bool __can_construct() {
      return is_constructible<type, _Args...>::value;
  }
  template <class _UArg>
  static constexpr bool __can_assign() {
    return is_assignable<type&, _UArg>::value
        && is_constructible<type, _UArg>::value;
  }
};

template <class _PossibleTp>
struct _CheckCtorImp<variant_npos, _PossibleTp> {
  template <class ...>
  static constexpr bool __can_construct() { return false; }
  template <class ...>
  static constexpr bool __can_assign() { return false; }
};


template <size_t _Idx, class _Type>
struct __variant_overload {
  using type = _Type;
  static constexpr size_t __index = _Idx;
};

template <class _Type>
struct __variant_overload<variant_npos, _Type> {
  using type = _Type;
  static constexpr size_t __index = variant_npos;
};

template <bool _Enable, size_t _Idx, class ..._Types>
struct __variant_overloads_imp {
  static_assert(sizeof...(_Types) == 0, "Wrong specialization selected");
  static __variant_overload<variant_npos, void> __fun();
};

template <size_t _Idx, class _T0, class... _TRest>
struct __variant_overloads_imp<true, _Idx, _T0, _TRest...>
    : __variant_overloads_imp<true, _Idx + 1, _TRest...> {
  using _BaseT = __variant_overloads_imp<true, _Idx + 1, _TRest...>;
  static __variant_overload<
        __find_exactly_one_t_checker<_T0, _Idx, _TRest...>::value
      , _T0>
  __fun(_T0);
  using _BaseT::__fun;
};

template <size_t _Idx, class ..._Types>
struct __variant_overloads_imp<false, _Idx, _Types...> { };

template <bool _Enable, class _Tp, class ..._Types>
auto __find_variant_overload_imp(int)
    -> decltype(__variant_overloads_imp<_Enable, 0, _Types...>::__fun(_VSTD::declval<_Tp>()));

template <bool _Enable, class _Tp, class ..._Types>
auto __find_variant_overload_imp(...)
    -> decltype(__variant_overload<variant_npos, void>{});

template <bool _Enable, class _Tp, class ..._Types>
using __find_variant_overload = decltype(
    __variant_detail::__find_variant_overload_imp<_Enable, _Tp, _Types...>(0));


template <class _VBase1, class _VBase2, class _AssignFn, class _CopyFn>
inline _LIBCPP_INLINE_VISIBILITY
void __do_base_assign(_VBase1& _LHS, _VBase2& _RHS, _AssignFn&& __afn, _CopyFn&& __cfn)
{
    if (_LHS.__which_ == variant_npos && _RHS.__which_ == variant_npos) {
        //
    } else if (_LHS.__which_ == _RHS.__which_) {
        _LHS.__imp_.template __visit<void>(_LHS.__which_, _RHS.__imp_, __afn);
    }
    else if (_RHS.__which_ == variant_npos) {
        _LHS.__which_ = variant_npos;
        _LHS.__imp_.__destroy();
    } else {
        __cfn();
        _LHS.__which_ = _RHS.__which_;
    }
}

} // namespace __variant_detail


struct __variant_end_tag {};
struct __variant_inplace_tag {};
struct __variant_alloc_tag {};

struct __variant_end_node {
  size_t __which_ = variant_npos;
};

template <size_t _Idx, class _Tp>
struct __variant_element {
    using element_type = _Tp;

    template <class ..._Args>
    constexpr __variant_element(__variant_inplace_tag, _Args&& ...__args)
        : __which_(_Idx), __value_(_VSTD::forward<_Args>(__args)...) {}

    template <class _Alloc, class ..._Args>
    __variant_element(__variant_alloc_tag, integral_constant<int, 0>, _Alloc const&,
                      _Args&& ...__args)
        : __which_(_Idx), __value_(_VSTD::forward<_Args>(__args)...) {}

    template <class _Alloc, class ..._Args>
    __variant_element(__variant_alloc_tag, integral_constant<int, 1>, _Alloc const& __a,
                      _Args&& ...__args)
        : __which_(_Idx), __value_(allocator_arg, __a, _VSTD::forward<_Args>(__args)...) {}

    template <class _Alloc, class ..._Args>
    __variant_element(__variant_alloc_tag, integral_constant<int, 2>, _Alloc const& __a,
                      _Args&& ...__args)
        : __which_(_Idx), __value_(_VSTD::forward<_Args>(__args)..., __a) {}

    size_t __which_;
    _Tp __value_;
};

template <bool _IsTriviallyDestructible, size_t _Idx, class ..._Types>
union _LIBCPP_TYPE_VIS_ONLY __variant_union {

};

template <size_t _Idx, class _T0,  class ..._TRest>
union _LIBCPP_TYPE_VIS_ONLY __variant_union<true, _Idx, _T0, _TRest...> {
    using _TailT = __variant_union<true, _Idx + 1, _TRest...>;
    constexpr __variant_union(__variant_end_tag) : __end_() {}

    template <class ..._Args>
    constexpr __variant_union(__variant_inplace_tag __tag, in_place_index_t<0>,
                              _Args&&... __args)
        : __head_(__tag, _VSTD::forward<_Args>(__args)...) {}

    template <class _Alloc, class ..._Args>
    __variant_union(__variant_alloc_tag __tag, in_place_index_t<0>,
                              _Alloc const& __a, _Args&&... __args)
        : __head_(__tag, __uses_alloc_ctor<_T0, _Alloc, _Args...>(),
                  __a, _VSTD::forward<_Args>(__args)...) {}

    template <class _Tag, size_t _OtherIdx, class ..._Args>
    constexpr __variant_union(_Tag __tag, in_place_index_t<_OtherIdx>,
                              _Args&&... __args)
        : __tail_(__tag, in_place_index<_OtherIdx - 1>,
                  _VSTD::forward<_Args>(__args)...) {}

    constexpr _T0& __get(in_place_index_t<0>) noexcept
    { return __head_.__value_; }

    constexpr const _T0& __get(in_place_index_t<0>) const noexcept
    { return __head_.__value_; }

    template <size_t _OIdx, enable_if_t<_OIdx - 1 <= sizeof...(_TRest), bool> = true>
    constexpr tuple_element_t<_OIdx - 1, __tuple_types<_TRest...>>&
    __get(in_place_index_t<_OIdx>) noexcept
    { return __tail_.__get(in_place_index<_OIdx - 1>); }

    template <size_t _OIdx, enable_if_t<_OIdx - 1 <= sizeof...(_TRest), bool> = true>
    constexpr tuple_element_t<_OIdx - 1, __tuple_types<_TRest...>> const &
    __get(in_place_index_t<_OIdx>) const noexcept
    { return __tail_.__get(in_place_index<_OIdx - 1>); }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
              enable_if_t<sizeof...(_TRest) != 0 && _Dummy, bool> = true>
    constexpr _Ret __visit(size_t __w, _Variant& __other, _Lambda&& __fn) {
        if (__w == _Idx) {
            return __fn(__head_.__value_, __other.__head_.__value_);
        } else {
            return __tail_.template __visit<_Ret>(__w, __other.__tail_, _VSTD::forward<_Lambda>(__fn));
        }
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
              enable_if_t<sizeof...(_TRest) != 0 && _Dummy, bool> = true>
    constexpr _Ret __visit(size_t __w, _Variant& __other, _Lambda&& __fn) const {
        if (__w == _Idx) {
            return __fn(__head_.__value_, __other.__head_.__value_);
        } else {
            return __tail_.template __visit<_Ret>(__w, __other.__tail_, _VSTD::forward<_Lambda>(__fn));
        }
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
            enable_if_t<sizeof...(_TRest) == 0 && _Dummy, bool> = true>
    constexpr _Ret __visit(size_t __w, _Variant& __other, _Lambda&& __fn) {
        _LIBCPP_ASSERT(__w == _Idx, "Out of range");
        return __fn(__head_.__value_, __other.__head_.__value_);
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
             enable_if_t<sizeof...(_TRest) == 0 && _Dummy, bool> = true>
    constexpr _Ret __visit(size_t __w, _Variant& __other, _Lambda&& __fn) const {
        _LIBCPP_ASSERT(__w  == _Idx, "Out of range");
        return __fn(__head_.__value_, __other.__head_.__value_);
    }
  
    
    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
              enable_if_t<sizeof...(_TRest) != 0 && _Dummy, bool> = true>
    constexpr _Ret __visit_internal(_Variant& __other, _Lambda&& __fn) {
        if (__other.__head_.__which_ == _Idx) {
            return __fn(__head_, __other.__head_);
        } else {
            return __tail_.template __visit_internal<_Ret>(__other.__tail_, _VSTD::forward<_Lambda>(__fn));
        }
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
              enable_if_t<sizeof...(_TRest) != 0 && _Dummy, bool> = true>
    constexpr _Ret __visit_internal(_Variant& __other, _Lambda&& __fn) const {
        if (__other.__head_.__which_ == _Idx) {
            return __fn(__head_, __other.__head_);
        } else {
            return __tail_.template __visit_internal<_Ret>(__other.__tail_, _VSTD::forward<_Lambda>(__fn));
        }
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
            enable_if_t<sizeof...(_TRest) == 0 && _Dummy, bool> = true>
    constexpr _Ret __visit_internal(_Variant& __other, _Lambda&& __fn) {
        _LIBCPP_ASSERT(__other.__head_.__which_ == _Idx, "Out of range");
        return __fn(__head_, __other.__head_);
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
             enable_if_t<sizeof...(_TRest) == 0 && _Dummy, bool> = true>
    constexpr _Ret __visit_internal(_Variant& __other, _Lambda&& __fn) const {
        _LIBCPP_ASSERT(__other.__head_.__which_ == _Idx, "Out of range");
        return __fn(__head_, __other.__head_);
    }

    void __destroy() {
        if (__head_.__which_ == variant_npos)
            return;
        if (__head_.__which_ == _Idx)
            __head_.~__variant_element();
        else
            __tail_.~_TailT();
        ::new((void*)&__end_) __variant_end_node();
    }

    ~__variant_union() = default;

public:
    __variant_end_node __end_;
    __variant_element<_Idx, _T0> __head_;
    _TailT __tail_;
};

template <size_t _Idx, class _T0,  class ..._TRest>
union _LIBCPP_TYPE_VIS_ONLY __variant_union<false, _Idx, _T0, _TRest...> {
    using _TailT =  __variant_union<false, _Idx + 1, _TRest...>;

    constexpr __variant_union(__variant_end_tag __t) : __end_() {}

    template <class ..._Args>
    constexpr __variant_union(__variant_inplace_tag __tag, in_place_index_t<0>,
                              _Args&&... __args)
        : __head_(__tag, _VSTD::forward<_Args>(__args)...) {}

    template <class _Alloc, class ..._Args>
    __variant_union(__variant_alloc_tag __tag, in_place_index_t<0>,
                              _Alloc const& __a, _Args&&... __args)
        : __head_(__tag, __uses_alloc_ctor<_T0, _Alloc, _Args...>(),
                  __a, _VSTD::forward<_Args>(__args)...) {}

    template <class _Tag, size_t _OtherIdx, class ..._Args>
    constexpr __variant_union(_Tag __tag, in_place_index_t<_OtherIdx>,
                              _Args&&... __args)
        : __tail_(__tag, in_place_index<_OtherIdx - 1>,
                  _VSTD::forward<_Args>(__args)...) {}

    constexpr _T0& __get(in_place_index_t<0>) noexcept
    { return __head_.__value_; }

    constexpr const _T0& __get(in_place_index_t<0>) const noexcept
    { return __head_.__value_; }

    template <size_t _OIdx, enable_if_t<_OIdx - 1 <= sizeof...(_TRest), bool> = true>
    constexpr tuple_element_t<_OIdx - 1, __tuple_types<_TRest...>>&
    __get(in_place_index_t<_OIdx>) noexcept
    { return __tail_.__get(in_place_index<_OIdx - 1>); }

    template <size_t _OIdx, enable_if_t<_OIdx - 1 <= sizeof...(_TRest), bool> = true>
    constexpr tuple_element_t<_OIdx - 1, __tuple_types<_TRest...>> const &
    __get(in_place_index_t<_OIdx>) const noexcept
    { return __tail_.__get(in_place_index<_OIdx - 1>); }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
              enable_if_t<sizeof...(_TRest) != 0 && _Dummy, bool> = true>
    constexpr _Ret __visit(size_t __w, _Variant& __other, _Lambda&& __fn) {
        if (__w == _Idx) {
            return __fn(__head_.__value_, __other.__head_.__value_);
        } else {
            return __tail_.template __visit<_Ret>(__w, __other.__tail_, _VSTD::forward<_Lambda>(__fn));
        }
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
              enable_if_t<sizeof...(_TRest) != 0 && _Dummy, bool> = true>
    constexpr _Ret __visit(size_t __w, _Variant& __other, _Lambda&& __fn) const {
        if (__w == _Idx) {
            return __fn(__head_.__value_, __other.__head_.__value_);
        } else {
            return __tail_.template __visit<_Ret>(__w, __other.__tail_, _VSTD::forward<_Lambda>(__fn));
        }
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
            enable_if_t<sizeof...(_TRest) == 0 && _Dummy, bool> = true>
    constexpr _Ret __visit(size_t __w, _Variant& __other, _Lambda&& __fn) {
        _LIBCPP_ASSERT(__w == _Idx, "Out of range");
        return __fn(__head_.__value_, __other.__head_.__value_);
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
             enable_if_t<sizeof...(_TRest) == 0 && _Dummy, bool> = true>
    constexpr _Ret __visit(size_t __w, _Variant& __other, _Lambda&& __fn) const {
        _LIBCPP_ASSERT(__w  == _Idx, "Out of range");
        return __fn(__head_.__value_, __other.__head_.__value_);
    }



    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
              enable_if_t<sizeof...(_TRest) != 0 && _Dummy, bool> = true>
    constexpr _Ret __visit_internal(_Variant& __other, _Lambda&& __fn) {
        if (__other.__head_.__which_ == _Idx) {
            return __fn(__head_, __other.__head_);
        } else {
            return __tail_.template __visit_internal<_Ret>(__other.__tail_, _VSTD::forward<_Lambda>(__fn));
        }
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
              enable_if_t<sizeof...(_TRest) != 0 && _Dummy, bool> = true>
    constexpr _Ret __visit_internal(_Variant& __other, _Lambda&& __fn) const {
        if (__other.__head_.__which_ == _Idx) {
            return __fn(__head_, __other.__head_);
        } else {
            return __tail_.template __visit_internal<_Ret>(__other.__tail_, _VSTD::forward<_Lambda>(__fn));
        }
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
            enable_if_t<sizeof...(_TRest) == 0 && _Dummy, bool> = true>
    constexpr _Ret __visit_internal(_Variant& __other, _Lambda&& __fn) {
        _LIBCPP_ASSERT(__other.__head_.__which_ == _Idx, "Out of range");
        return __fn(__head_, __other.__head_);
    }

    template <class _Ret, class _Variant, class _Lambda, bool _Dummy = true,
             enable_if_t<sizeof...(_TRest) == 0 && _Dummy, bool> = true>
    constexpr _Ret __visit_internal(_Variant& __other, _Lambda&& __fn) const {
        _LIBCPP_ASSERT(__other.__head_.__which_ == _Idx, "Out of range");
        return __fn(__head_, __other.__head_);
    }


    void __destroy(bool __reconstruct = true) {
        if (__head_.__which_ == variant_npos)
            return;
        if (__head_.__which_ == _Idx)
            __head_.~__variant_element();
        else
            __tail_.~_TailT();
        if (__reconstruct)
            ::new((void*)&__end_) __variant_end_node();
    }

    ~__variant_union() { __destroy(false); }

public:
    __variant_end_node __end_;
    __variant_element<_Idx, _T0> __head_;
    _TailT __tail_;
};


template <bool _HasTDtor, bool _HasTCopy, class ..._Types>
class __variant_base {
    static_assert(_HasTCopy, "");
public:
  using _Imp = __variant_union<_HasTDtor, 0, _Types...>;
  _Imp __imp_;
  size_t __which_ = variant_npos;

  __variant_base(__variant_end_tag __tag) : __imp_(__tag)  {}

  template <class _Tag, size_t _OtherIdx, class ..._Args>
  constexpr __variant_base(_Tag __tag, in_place_index_t<_OtherIdx>, _Args&&... __args)
        : __imp_(__tag, in_place_index<_OtherIdx>, _VSTD::forward<_Args>(__args)...),
          __which_(_OtherIdx) {}

  __variant_base(__variant_base const&) = default;
  __variant_base(__variant_base&&) = default;

  __variant_base& operator=(__variant_base const& __v) {
      __variant_detail::__do_base_assign(*this, __v,
        [](auto& __my_val, auto& __other_val) { __my_val = __other_val; },
        [&]() {
          __variant_base __tmp(__v);
          __which_ = variant_npos;
          __imp_.__destroy();
          ::new((void*)&__imp_) _Imp(_VSTD::move(__tmp.__imp_));
          __which_ = __tmp.__which_;
        });
     return *this;
  }

  __variant_base& operator=(__variant_base&& __v)
    noexcept(__all<is_nothrow_move_constructible_v<_Types>...,
                   is_nothrow_move_assignable_v<_Types>...>::value)
  {
      __variant_detail::__do_base_assign(*this, __v,
        [](auto& __my_val, auto& __other_val) {
          __my_val = _VSTD::move(__other_val);
        },
        [&]() {
          __which_ = variant_npos;
          __imp_.__destroy();
          ::new((void*)&__imp_) _Imp(_VSTD::move(__v.__imp_));
          __which_ = __v.__which_;
        });
     return *this;
  }
};

template <bool _HasTDtor, class ..._Types>
class __variant_base<_HasTDtor, false, _Types...> {
public:
  using _Imp = __variant_union<_HasTDtor, 0, _Types...>;
  _Imp __imp_;
  size_t __which_ = variant_npos;

  __variant_base(__variant_end_tag __tag) : __imp_(__tag) {}

  template <class _Tag, size_t _OtherIdx, class ..._Args>
  constexpr __variant_base(_Tag __tag, in_place_index_t<_OtherIdx>,
                           _Args&&... __args)
        : __imp_(__tag, in_place_index<_OtherIdx>, _VSTD::forward<_Args>(__args)...),
          __which_(_OtherIdx) {}

  void __move_construct(__variant_base& __v) {
      __imp_.template __visit_internal<void>(__v.__imp_, [&](auto& __my_head, auto& __other_head) {
        using _HeadT = remove_reference_t<decltype(__my_head)>;
        ::new ((void*)&__my_head) _HeadT(_VSTD::move(__other_head));
        __which_ = __other_head.__which_;
      });
  }

  __variant_base(__variant_base const& __v) : __imp_(__variant_end_tag{}) {
      __imp_.template __visit_internal<void>(__v.__imp_, [&](auto& __my_head, auto& __other_head) {
        using _HeadT = remove_reference_t<decltype(__my_head)>;
        ::new ((void*)&__my_head) _HeadT(__other_head);
        __which_ = __other_head.__which_;
      });
  }

  __variant_base(__variant_base&& __v)
        noexcept(__all<is_nothrow_move_constructible<_Types>::value...>::value)
    : __imp_(__variant_end_tag{})
  {
      __move_construct(__v);
  }

  __variant_base& operator=(__variant_base const& __v) {
    __variant_detail::__do_base_assign(*this, __v,
        [](auto& __my_val, auto& __other_val) {
          __my_val = __other_val;
        },
        [&]() {
          __variant_base __tmp(__v);
          __which_ = variant_npos;
          __imp_.__destroy();
          __move_construct(__tmp);
        });
     return *this;
  }

  __variant_base& operator=(__variant_base&& __v)
    noexcept(__all<is_nothrow_move_constructible_v<_Types>...,
                   is_nothrow_move_assignable_v<_Types>...>::value)
  {
      __variant_detail::__do_base_assign(*this, __v,
        [](auto& __my_val, auto& __other_val) {
          __my_val = _VSTD::move(__other_val);
        },
        [&]() {
          __which_ = variant_npos;
          __imp_.__destroy();
          __move_construct(__v);
        });
     return *this;
  }
};

template <>
class _LIBCPP_TYPE_VIS_ONLY variant<> {
    // TODO(EricWF) WTF?
};

template <class ..._Types>
class _LIBCPP_TYPE_VIS_ONLY variant
    : public __variant_detail::__variant_sfinae_base_t<_Types...>
{
    // private typedefs
    using _Base = __variant_base<
        __all<is_trivially_destructible<_Types>::value...>::value,
        __all<is_trivially_copy_constructible<_Types>::value...>::value,
        _Types...
    >;
    using _CtorBase = __variant_detail::__variant_sfinae_base_t<_Types...>;
    using _First = variant_alternative_t<0, variant>;

    // private SFINAE helpers
    template <size_t _Idx,
              size_t _BoundIdx = _Idx < sizeof...(_Types) ? _Idx : variant_npos>
    using _CheckCtorIdx = __variant_detail::_CheckCtorImp<
        _BoundIdx, variant_alternative<_BoundIdx, variant>>;

    template <size_t _Idx, class ..._Args>
    using _EnableCtorIdx =
        enable_if_t<_CheckCtorIdx<_Idx>::template __can_construct<_Args...>()>;

    template <class _Tp,
              class _Found = __find_exactly_one_unchecked<_Tp, _Types...>>
    using _CheckCtorTp =
        __variant_detail::_CheckCtorImp<_Found::value, __identity<_Tp>>;

    template <class _Tp, class ..._Args>
    using _EnableCtorTp =
        enable_if_t<_CheckCtorTp<_Tp>::template __can_construct<_Args...>()>;

    template <class _Arg,
              class _Found = __variant_detail::__find_variant_overload<
                  !is_same<decay_t<_Arg>, variant>::value, _Arg, _Types...>>
    using _CheckArg =
        __variant_detail::_CheckCtorImp<_Found::__index, _Found>;

    template <class _Arg, class _Tp>
    using _EnableArg =
        enable_if_t<_CheckArg<_Arg>::template __can_construct<_Tp>()>;

  // private misc helpers
  template <size_t _Idx, class ..._Args>
  void __overwrite_base(_Args&& ...__args) {
    if (__base_.__which_ != variant_npos) {
        __base_.__which_ = variant_npos;
        __base_.__imp_.__destroy();
    }
    ::new((void*)&__base_.__imp_) typename _Base::_Imp(
        __variant_inplace_tag{}, in_place_index<_Idx>,
        _VSTD::forward<_Args>(__args)...);
    __base_.__which_ = _Idx;
  }

public:
    // ?.3.1 Constructors
    template <bool _Dummy = true, class = enable_if_t<
        __dependent_type<is_default_constructible<_First>, _Dummy>::value>>
    constexpr variant() noexcept(is_nothrow_default_constructible<_First>::value)
        : __base_(__variant_inplace_tag{}, in_place_index<0>) {}

    variant(variant const&) = default;
    variant(variant&&) = default;

    template <class _Tp,
              class _Found = _CheckArg<_Tp>,
              class = enable_if_t<_Found::template __can_construct<_Tp>()>>
    constexpr variant(_Tp&& __t)
            noexcept(is_nothrow_constructible<typename _Found::type, _Tp>::value)
        : __base_(__variant_inplace_tag{}, in_place_index<_Found::__index>,
                  _VSTD::forward<_Tp>(__t)) {}

    template <class _Tp, class... _Args,
              class = _EnableCtorTp<_Tp, _Args...>>
    constexpr explicit variant(in_place_type_t<_Tp>, _Args&&... __args)
        : __base_(__variant_inplace_tag{}, _CheckCtorTp<_Tp>::__ip,
                  _VSTD::forward<_Args>(__args)...) {}

    template <class _Tp, class _Up, class... _Args,
              class = _EnableCtorTp<_Tp, initializer_list<_Up>, _Args...>>
    constexpr explicit variant(in_place_type_t<_Tp>, initializer_list<_Up> __il,
                               _Args&&... __args)
        : __base_(__variant_inplace_tag{}, _CheckCtorTp<_Tp>::__ip,
                  _VSTD::move(__il), _VSTD::forward<_Args>(__args)...) {}

    template <size_t _Idx, class... _Args,
              class = _EnableCtorIdx<_Idx, _Args...>>
    constexpr explicit variant(in_place_index_t<_Idx> __i, _Args&&... __args)
        : __base_(__variant_inplace_tag{}, __i, _VSTD::forward<_Args>(__args)...) {}

    template <size_t _Idx, class _Up, class... _Args,
              class = _EnableCtorIdx<_Idx, initializer_list<_Up>, _Args...>>
    constexpr explicit variant(in_place_index_t<_Idx> __i,
                               initializer_list<_Up> __il, _Args&&... __args)
        : __base_(__variant_inplace_tag{}, __i, _VSTD::move(__il),
                  _VSTD::forward<_Args>(__args)...) {}

    // allocator-extended constructors
    template <class _Alloc, bool _Dummy = true, class = enable_if_t<
        __dependent_type<is_default_constructible<_First>, _Dummy>::value>>
    variant(allocator_arg_t, const _Alloc& __a)
        : __base_(__variant_alloc_tag{}, in_place_index<0>, __a) {}

    template <class _Alloc, bool _Dummy = true, class = enable_if_t<_CtorBase::__copy && _Dummy>>
    variant(allocator_arg_t __t, const _Alloc& __a, const variant& __v)
        : __base_(__variant_end_tag{})
    {
        __base_.__imp_.template __visit_internal<void>(__v.__base_.__imp_,
            [&](auto& __my_head, auto const& __other_head) {
                using _HeadT = remove_reference_t<decltype(__my_head)>;
                using _T0 = typename _HeadT::element_type;
                ::new ((void*)&__my_head) _HeadT(
                    __variant_alloc_tag{}, __uses_alloc_ctor<_T0, _Alloc, _T0 const&>(),
                    __a, __other_head.__value_);
                __base_.__which_ = __other_head.__which_;
            }
        );
    }

    template <class _Alloc, bool _Dummy = true, class = enable_if_t<_CtorBase::__move && _Dummy>>
    variant(allocator_arg_t __t, const _Alloc& __a, variant&& __v)
        : __base_(__variant_end_tag{}) {
        __base_.__imp_.template __visit_internal<void>(__v.__base_.__imp_,
            [&](auto& __my_head, auto& __other_head) {
                using _HeadT = remove_reference_t<decltype(__my_head)>;
                using _T0 = typename _HeadT::element_type;
                ::new ((void*)&__my_head) _HeadT(
                    __variant_alloc_tag{}, __uses_alloc_ctor<_T0, _Alloc, _T0 &&>(),
                    __a, _VSTD::move(__other_head.__value_));
                __base_.__which_ = __other_head.__which_;
            }
        );
    }

    template <class _Alloc, class _Tp,
              class = enable_if_t<_CheckArg<_Tp>::template __can_construct<_Tp>()>>
    variant(allocator_arg_t, const _Alloc& __a, _Tp&& __tp)
        : __base_(__variant_alloc_tag{}, in_place_index<_CheckArg<_Tp>::__index>,
                  __a, _VSTD::forward<_Tp>(__tp)) {}

    template <class _Alloc, class _Tp, class... _Args,
              class = _EnableCtorTp<_Tp, _Args...>>
    variant(allocator_arg_t, const _Alloc& __a, in_place_type_t<_Tp>, _Args&&... __args)
        : __base_(__variant_alloc_tag{}, _CheckCtorTp<_Tp>::__ip, __a,
                  _VSTD::forward<_Args>(__args)...) {}

    template <class _Alloc, class _Tp, class _Up, class... _Args,
              class = _EnableCtorTp<_Tp, initializer_list<_Up>, _Args...>>
    variant(allocator_arg_t, const _Alloc& __a, in_place_type_t<_Tp>,
            initializer_list<_Up> __il, _Args&&... __args)
        : __base_(__variant_alloc_tag{}, _CheckCtorTp<_Tp>::__ip, __a,
                  _VSTD::move(__il), _VSTD::forward<_Args>(__args)...) {}

    template <class _Alloc, size_t _Idx, class... _Args,
              class = _EnableCtorIdx<_Idx, _Args...>>
    variant(allocator_arg_t, const _Alloc& __a, in_place_index_t<_Idx> __i,
            _Args&&... __args)
        : __base_(__variant_alloc_tag{}, __i, __a, _VSTD::forward<_Args>(__args)...) {}

    template <class _Alloc, size_t _Idx, class _Up, class... _Args,
              class = _EnableCtorIdx<_Idx, initializer_list<_Up>, _Args...>>
    variant(allocator_arg_t, const _Alloc& __a, in_place_index_t<_Idx> __i,
            initializer_list<_Up> __il, _Args&&... __args)
        : __base_(__variant_alloc_tag{}, __i, __a, _VSTD::move(__il),
                  _VSTD::forward<_Args>(__args)...) {}

    // ?.3.2, Destructor
    ~variant() = default;

    // ?.3.3, Assignment
    variant& operator=(const variant&) = default;
    variant& operator=(variant&&) = default;

    template <class _Tp, class _CA = _CheckArg<_Tp>,
              class = enable_if_t<_CA::template __can_assign<_Tp>()>>
    variant& operator=(_Tp&& __tp)
        noexcept(is_nothrow_assignable_v<typename _CA::type&, _Tp>
              && is_nothrow_constructible_v<typename _CA::type, _Tp>)
    {
        if (_CA::__index == __base_.__which_) {
            _VSTD::get<_CA::__index>(*this) = _VSTD::forward<_Tp>(__tp);
            return *this;
        }
        __overwrite_base<_CA::__index>(_VSTD::forward<_Tp>(__tp));
        return *this;
    }

    // ?.3.4, Modifiers
    template <class _Tp, class... _Args,
              class =_EnableCtorTp<_Tp, _Args...>>
    void emplace(_Args&&... __args) {
        __overwrite_base<_CheckCtorTp<_Tp>::__index>(
            _VSTD::forward<_Args>(__args)...);
    }

    template <class _Tp, class _Up, class... _Args,
              class = _EnableCtorTp<_Tp, initializer_list<_Up>, _Args...>>
    void emplace(initializer_list<_Up> __il, _Args&&... __args) {
        __overwrite_base<_CheckCtorTp<_Tp>::__index>(
            _VSTD::move(__il), _VSTD::forward<_Args>(__args)...);
    }

    template <size_t _Idx, class... _Args,
              class = _EnableCtorIdx<_Idx, _Args...>>
    void emplace(_Args&&... __args) {
        __overwrite_base<_Idx>(_VSTD::forward<_Args>(__args)...);
    }

    template <size_t _Idx, class _Up, class... _Args,
              class = _EnableCtorIdx<_Idx, initializer_list<_Up>, _Args...>>
    void emplace(initializer_list<_Up> __il, _Args&&... __args) {
        __overwrite_base<_Idx>(_VSTD::move(__il),
                               _VSTD::forward<_Args>(__args)...);
    }

    // ?.3.5, Value status
    _LIBCPP_INLINE_VISIBILITY
    constexpr bool valueless_by_exception() const noexcept {
        return index() == variant_npos;
    }

    _LIBCPP_INLINE_VISIBILITY
    constexpr size_t index() const noexcept {
        return __base_.__which_;
    }

    // ?.3.6, Swap
    void swap(variant&) /* TODO noexcept(see below) */;

public: // TODO Make this private
    template <class _Ret, class _Variant, class _Lambda>
    constexpr _Ret __visit(_Variant& __v, _Lambda&& __fn) {
        return __base_.__imp_.template __visit<_Ret>(__v.__base_.__which_,
                                                     __v.__base_.__imp_, __fn);
    }

    template <class _Ret, class _Variant, class _Lambda>
    constexpr _Ret __visit(_Variant& __v, _Lambda&& __fn) const {
        return __base_.__imp_.template __visit<_Ret>(__v.__base_.__which_,
                                                     __v.__base_.__imp_, __fn);
    }

    _Base __base_;
};

template <class ..._Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr bool
operator==(variant<_Types...> const& _LHS, variant<_Types...> const& _RHS) noexcept
{
    using _VT = variant<_Types...>;
    return (_LHS.valueless_by_exception() && _RHS.valueless_by_exception()) ||
        (_LHS.index() == _RHS.index() &&
            _LHS.template __visit<bool>(_RHS, equal_to<>{}));
}


template <class ..._Types>
inline _LIBCPP_INLINE_VISIBILITY
constexpr bool
operator!=(variant<_Types...> const& _LHS, variant<_Types...> const& _RHS) noexcept
{
    return !(_LHS == _RHS);
}

struct _LIBCPP_TYPE_VIS_ONLY monostate {};

inline _LIBCPP_INLINE_VISIBILITY
constexpr bool operator<(monostate, monostate) noexcept { return false; }

inline _LIBCPP_INLINE_VISIBILITY
constexpr bool operator>(monostate, monostate) noexcept { return false; }

inline _LIBCPP_INLINE_VISIBILITY
constexpr bool operator<=(monostate, monostate) noexcept { return true; }

inline _LIBCPP_INLINE_VISIBILITY
constexpr bool operator>=(monostate, monostate) noexcept { return true; }

inline _LIBCPP_INLINE_VISIBILITY
constexpr bool operator==(monostate, monostate) noexcept { return true; }

inline _LIBCPP_INLINE_VISIBILITY
constexpr bool operator!=(monostate, monostate) noexcept { return false; }

_LIBCPP_END_NAMESPACE_STD

#endif // _LIBCPP_STD_VER > 14

#endif  // _LIBCPP_VARIANT
